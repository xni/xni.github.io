<!DOCTYPE html>
<!-- saved from url=(0217)http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2 -->
<html lang="ru" dir="ltr" class="client-js ve-not-available"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>Монадические комбинаторы парсеров — Викиучебник</title>
<meta name="generator" content="MediaWiki 1.25wmf16">
<link rel="alternate" type="application/x-wiki" title="Править" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit">
<link rel="edit" title="Править" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit">
<link rel="shortcut icon" href="http://bits.wikimedia.org/favicon/wikibooks.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://ru.wikibooks.org/w/opensearch_desc.php" title="Викиучебник (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://ru.wikibooks.org/w/api.php?action=rsd">
<link rel="alternate" hreflang="x-default" href="./Монадические комбинаторы парсеров — Викиучебник_files/Монадические комбинаторы парсеров — Викиучебник.html">
<link rel="copyright" href="http://creativecommons.org/licenses/by-sa/3.0/">
<link rel="alternate" type="application/atom+xml" title="Викиучебник — Atom-лента" href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&feed=atom">
<link rel="canonical" href="./Монадические комбинаторы парсеров — Викиучебник_files/Монадические комбинаторы парсеров — Викиучебник.html">
<link rel="stylesheet" href="http://bits.wikimedia.org/ru.wikibooks.org/load.php?debug=false&lang=ru&modules=ext.uls.nojs%7Cext.visualEditor.viewPageTarget.noscript%7Cext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&only=styles&skin=vector&*">
<style>
.tipsy{padding:5px;position:absolute;z-index:100000;cursor:default}.tipsy-inner{padding:5px 8px 4px 8px; background-color:#ffffff;border:solid 1px #a7d7f9;color:black;max-width:15em;border-radius:4px; }.tipsy-arrow{position:absolute;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALAgMAAADUwp+1AAAACVBMVEX5+fmn1/n///9s6BFKAAAAAXRSTlMAQObYZgAAACpJREFUCB1jZBD4wMiQMoeRcUU4I9uSaYxSE54xZjn8AtMgPkgcJA9UBwAeDw1Qrb3pVAAAAABJRU5ErkJggg==) no-repeat top left;background:url(//bits.wikimedia.org/static-1.25wmf16/resources/src/jquery.tipsy/images/tipsy.png?2015-02-05T19:23:20Z) no-repeat top left!ie;width:11px;height:6px} .tipsy-n .tipsy-arrow{top:0px;left:50%;margin-left:-5px} .tipsy-nw .tipsy-arrow{top:1px;left:10px} .tipsy-ne .tipsy-arrow{top:1px;right:10px} .tipsy-s .tipsy-arrow{bottom:0px;left:50%;margin-left:-5px;background-position:bottom left} .tipsy-sw .tipsy-arrow{bottom:0px;left:10px;background-position:bottom left} .tipsy-se .tipsy-arrow{bottom:0px;right:10px;background-position:bottom left} .tipsy-e .tipsy-arrow{top:50%;margin-top:-5px;right:1px;width:5px;height:11px;background-position:top right} .tipsy-w .tipsy-arrow{top:50%;margin-top:-5px;left:0px;width:6px;height:11px} .tipsy{font-size:0.8em}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:94bf994165c2a36e3da76f1289d7496b */
@media print{#centralNotice{display:none}}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:ddb0c98a055632ae8e349c9cf48ac703 */
.uls-menu a{cursor:pointer}.uls-menu.callout .caret-before{border-top:20px solid transparent;border-right:20px solid #C9C9C9;border-bottom:20px solid transparent;display:inline-block;left:-21px;top:30px;position:absolute}.uls-menu.callout .caret-after{border-top:20px solid transparent;border-right:20px solid #FCFCFC;border-bottom:20px solid transparent;display:inline-block;left:-20px;top:30px;position:absolute}.uls-ui-languages button{width:23%;text-overflow:ellipsis;margin-right:4%}button.uls-more-languages{width:auto}.settings-title{font-size:11pt}.settings-text{color:#555555;font-size:9pt}div.display-settings-block:hover .settings-text{color:#252525}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:22d1681fa868b4ff4fbcb1ec1e58a9ea */
@-webkit-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-webkit-transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0)}}@-moz-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-moz-transform:translateY(-20px)}100%{opacity:1;-moz-transform:translateY(0)}}@-o-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-o-transform:translateY(-20px)}100%{opacity:1;-o-transform:translateY(0)}}@keyframes centralAuthPPersonalAnimation{0%{opacity:0;transform:translateY(-20px)}100%{opacity:1;transform:translateY(0)}}.centralAuthPPersonalAnimation{-webkit-animation-duration:1s;-moz-animation-duration:1s;-o-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;-o-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-name:centralAuthPPersonalAnimation;-moz-animation-name:centralAuthPPersonalAnimation;-o-animation-name:centralAuthPPersonalAnimation;animation-name:centralAuthPPersonalAnimation}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:0dcacc990dd02e7db9669ab3090b80f1 */
.mw-viewPageTarget-loading{width:128px;height:15px;float:right} .mw-editsection{white-space:nowrap; unicode-bidi:-moz-isolate;unicode-bidi:-webkit-isolate;unicode-bidi:isolate}.mw-editsection-divider{color:#555}.ve-tabmessage-appendix{font-size:0.7em;vertical-align:top;line-height:1.43em;padding-left:0.5em; background-image:none !important;display:inline !important} .mw-viewPageTarget-loading{background-image:url(data:image/gif;base64,R0lGODlhgAAPAPEAAP///6fX+eXy/KfX+SH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAgAAPAAACo5QvoIC33NKKUtF3Z8RbN/55CEiNonMaJGp1bfiaMQvBtXzTpZuradUDZmY+opA3DK6KwaQTCbU9pVHc1LrDUrfarq765Ya9u+VRzLyO12lwG10yy39zY11Jz9t/6jf5/HfXB8hGWKaHt6eYyDgo6BaH6CgJ+QhnmWWoiVnI6ddJmbkZGkgKujhplNpYafr5OooqGst66Uq7OpjbKmvbW/p7UAAAIfkECQoAAAAsAAAAAIAADwAAArCcP6Ag7bLYa3HSZSG2le/Zgd8TkqODHKWzXkrWaq83i7V5s6cr2f2TMsSGO9lPl+PBisSkcekMJphUZ/OopGGfWug2Jr16x92yj3w247bh6teNXseRbyvc0rbr6/x5Ng0op4YSJDb4JxhI58eliEiYYujYmFi5eEh5OZnXhylp+RiaKQpWeDf5qQk6yprawMno2nq6KlsaSauqS5rLu8cI69k7+ytcvGl6XDtsyzxcAAAh+QQJCgAAACwAAAAAgAAPAAACvpw/oIC3IKIUb8pq6cpacWyBk3htGRk1xqMmZviOcemdc4R2kF3DvfyTtFiqnPGm+yCPQdzy2RQMF9Moc+fDArU0rtMK9SYzVUYxrASrxdc0G00+K8ruOu+9tmf1W06ZfsfXJfiFZ0g4ZvEndxjouPfYFzk4mcIICJkpqUnJWYiYs9jQVpm4edqJ+lkqikDqaZoquwr7OtHqAFerqxpL2xt6yQjKO+t7bGuMu1L8a5zsHI2MtOySVwo9fb0bVQAAIfkECQoAAAAsAAAAAIAADwAAAsucP6CAt9zSErSKZyvOd/KdgZaoeaFpRZKiPi1aKlwnfzBF4jcNzDk/e7EiLuLuhzwqayfmaNnjCCGNYhXqw9qcsWjT++TqxIKp2UhOprXf7PoNrpyvQ3p8fAdu82o+O5w3h2A1+Nfl5geHuLgXhEZVWBeZSMnY1oh5qZnyKOhgiGcJKHqYOSrVmWpHGmpauvl6CkvhaUD4qejaOqvH2+doV7tSqdsrexybvMsZrDrJaqwcvSz9i9qM/Vxs7Qs6/S18a+vNjUx9/v1TAAAh+QQJCgAAACwAAAAAgAAPAAAC0Zw/oIC33NKKUomLxct4c718oPV5nJmhGPWwU9TCYTmfdXp3+aXy+wgQuRRDSCN2/PWAoqVTCSVxilQZ0RqkSXFbXdf3ZWqztnA1eUUbEc9wm8yFe+VguniKPbNf6mbU/ubn9ieUZ6hWJAhIOKbo2Pih58C3l1a5OJiJuflYZidpgHSZCOnZGXc6l3oBWrE2aQnLWYpKq2pbV4h4OIq1eldrigt8i7d73Ns3HLjMKGycHC1L+hxsXXydO9wqOu3brPnLXL3C640sK+6cTaxNflEAACH5BAkKAAAALAAAAACAAA8AAALVnD+ggLfc0opS0SeyFnjn7oGbqJHf4mXXFD2r1bKNyaEpjduhPvLaC5nJEK4YTKhI1ZI334m5g/akJacAiDUGiUOHNUd9ApTgcTN81WaRW++Riy6Tv/S4dQ1vG4ps4NwOaBYlOEVYhYbnplexyJf3ZygGOXkWuWSZuNel+aboV0k5GFo4+qN22of6CMoq2kr6apo6m5fJWCoZm+vKu2Hr6KmqiHtJLKebRhuszNlYZ3ncewh9J9z8u3mLHA0rvetrzYjd2Wz8bB6oNO5MLq6FTp2+bVUAACH5BAkKAAAALAAAAACAAA8AAALanD+ggLfc0opS0XeX2Fy8zn2gp40ieHaZFWHt9LKNO5eo3aUhvisj6RutIDUZgnaEFYnJ4M2Z4210UykQ8BtqY0yHstk1UK+/sdk63i7VYLYX2sOa0HR41S5wi7/vcMWP1FdWJ/dUGIWXxqX3xxi4l0g4GEl5yOHIBwmY2cg1aXkHSjZXmbV4uoba5kkqelbaapo6u0rbN/SZG7trKFv7e6savKTby4voaoVpNAysiXscV4w8fSn8fN1pq1kd2j1qDLK8yYy9/ff9mgwrnv2o7QwvGO1ND049UgAAIfkECQoAAAAsAAAAAIAADwAAAticP6CAt9zSilLRd2d8onvBfV0okp/pZdamNRi7ui3yyoo4Ljio42h+w6kgNiJt5kAaasdYE7D78YKlXpX6GWphxqTT210qK1Cf9XT2SKXbYvv5Bg+jaWD5ekdjU9y4+PsXRuZHRrdnZ5inVidAyCTXF+nGlVhpdjil2OE49hjICVh4qZlpibcDKug5KAlHOWqqR8rWCjl564oLFruIucaYGlz7+XoKe2wsIqxLzMxaxIuILIs6/JyLbZsdGF063Uu6vH2tXc79LZ1MLWS96t4JH/rryzhPWgAAIfkECQoAAAAsAAAAAIAADwAAAtWcP6CAt9zSilLRd2fEe4kPCk8IjqTonZnVsQ33arGLwLV8Kyeqnyb5C60gM2LO6MAlaUukwdbcBUspYFXYcla00KfSywRzv1vpldqzprHFoTv7bsOz5jUaUMer5vL+Mf7Hd5RH6HP2AdiUKLa41Tj1Acmjp0bJFuinKKiZyUhnaBd5OLnzSNbluOnZWQZqeVdIYhqWyop6ezoquTs6O0aLC5wrHErqGnvJibms3LzKLIYMe7xnO/yL7TskLVosqa1aCy3u3FrJbSwbHpy9fr1NfR4fUgAAIfkECQoAAAAsAAAAAIAADwAAAsqcP6CAt9zSilLRd2fEW7cnhKIAjmFpZla3fh7CuS38OrUR04p5Ljzp46kgMqLOaJslkbhbhfkc/lAjqmiIZUFzy2zRe5wGTdYQuKs9N5XrrZPbFu94ZYE6ms5/9cd7/T824vdGyIa3h9inJQfA+DNoCHeomIhWGUcXKFIH6RZZ6Bna6Zg5l8JnSamayto2WtoI+4jqSjvZelt7+URKpmlmKykM2vnqa1r1axdMzPz5LLooO326Owxd7Bzam4x8pZ1t3Szu3VMOdF4AACH5BAkKAAAALAAAAACAAA8AAAK/nD+ggLfc0opS0XdnxFs3/i3CSApPSWZWt4YtAsKe/DqzXRsxDqDj6VNBXENakSdMso66WzNX6fmAKCXRasQil9onM+oziYLc8tWcRW/PbGOYWupG5Tsv3TlXe9/jqj7ftpYWaPdXBzbVF2eId+jYCAn1KKlIApfCSKn5NckZ6bnJpxB2t1kKinoqJCrlRwg4GCs4W/jayUqamaqryruES2b72StsqgvsKlurDEvbvOx8mzgazNxJbD18PN1aUgAAIfkECQoAAAAsAAAAAIAADwAAArKcP6CAt9zSilLRd2fEWzf+ecgjlKaQWZ0asqPowAb4urE9yxXUAqeZ4tWEN2IOtwsqV8YkM/grLXvTYbV4PTZpWGYU9QxTxVZyd4wu975ZZ/qsjsPn2jYpatdx62b+2y8HWMTW5xZoSIcouKjYePeTh7TnqFcpabmFSfhHeemZ+RkJOrp5OHmKKapa+Hiyyokaypo6q1CaGDv6akoLu3DLmLuL28v7CdypW6vsK9vsE1UAACH5BAkKAAAALAAAAACAAA8AAAKjnD+ggLfc0opS0XdnxFs3/nkISI2icxokanVt+JoxC8G1fNOlm6tp1QNmZj6ikDcMrorBpBMJtT2lUdzUusNSt9qurvrlhr275VHMvI7XaXAbXTLLf3NjXUnP23/qN/n8d9cHyEZYpoe3p5jIOCjoFofoKAn5CGeZZaiJWcjp10mZuRkaSAq6OGmU2lhp+vk6iioay3rpSrs6mNsqa9tb+ntQAAA7AAAAAAAAAAAA);background-image:url(//bits.wikimedia.org/static-1.25wmf16/extensions/VisualEditor/modules/ve-mw/init/styles/images/loading-ltr.gif?2015-02-05T19:28:20Z)!ie}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:a95ea6f8f2ddb5237f090aef4956c4f1 */</style><style>
#p-lang .uls-settings-trigger{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAgCAQAAACI54EcAAAAAnNCSVQICFXsRgQAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAABWklEQVQoz42RwWrCQBBAc/PkyXiQfpEXobKzEsipCkKh5CBUhBBmaWrw6j/oIQr6VeaSXzDpZDbZ1CWVMhBm5zGT2X1O6fwdv1L0saTwLajmar0d4JHh6XuEofqooVpiQcU7ozbeGWJklXVEGrrcWWKOCUXOeYEuQeXhQaNdv/rPrl/jFH3HjEnM1klTa2FsYNzCBV45zfa9Cu17mPH5gm903A7rhW60d0Rf7opf9D03nVf50jCwyjxHrZvnCzCkR0sZndFVK/y0Hl7NGC46rTxV9hRKH0oope0T5nL9OhDHCsJpOhKhaHyKJRRUvDMyIbRPiB7LdWifnsudJeSQUOScF17lU3pw0GjCPid9jWUqfceMMT6pu6610PiE2ECxgCun2Zh9jnuQ8fkiK58wrBe60d4RfXWf9ik2XVeR2icEFuA5svEJgQinI5kyOnuuWAnbJ8z42f7r8wfhovZYX3llNQAAAABJRU5ErkJggg==) no-repeat right top;background:transparent url(//bits.wikimedia.org/static-1.25wmf16/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.png?2015-02-05T19:28:20Z) no-repeat right top!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%2214%22%20height%3D%2232%22%3E%3Cdefs%3E%3Cpath%20d%3D%22M14%209.3V6.73l-1.575-.264c-.117-.44-.292-.848-.496-1.2l.93-1.285-1.81-1.84-1.31.908c-.38-.205-.79-.38-1.196-.497L8.284%201H5.716l-.263%201.578c-.437.117-.816.293-1.196.497L2.975%202.17%201.137%203.98l.934%201.287c-.2.38-.376.79-.493%201.228L0%206.73V9.3l1.575.264c.117.438.292.818.496%201.198l-.93%201.315L2.95%2013.89l1.312-.938c.38.205.787.38%201.224.497L5.746%2015h2.566l.263-1.578c.408-.117.817-.293%201.196-.497l1.315.935%201.81-1.812-.935-1.315c.203-.38.38-.76.495-1.2L14%209.303zm-7%201.404c-1.488%200-2.683-1.2-2.683-2.69S5.542%205.327%207%205.327c1.458%200%202.683%201.198%202.683%202.69%200%201.49-1.195%202.688-2.683%202.688z%22%20id%3D%22a%22%2F%3E%3C%2Fdefs%3E%3Cuse%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23808080%22%2F%3E%3Cuse%20transform%3D%22translate%280%2016%29%22%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E%0A);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf16/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.svg?2015-02-05T19:28:20Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%2214%22%20height%3D%2232%22%3E%3Cdefs%3E%3Cpath%20d%3D%22M14%209.3V6.73l-1.575-.264c-.117-.44-.292-.848-.496-1.2l.93-1.285-1.81-1.84-1.31.908c-.38-.205-.79-.38-1.196-.497L8.284%201H5.716l-.263%201.578c-.437.117-.816.293-1.196.497L2.975%202.17%201.137%203.98l.934%201.287c-.2.38-.376.79-.493%201.228L0%206.73V9.3l1.575.264c.117.438.292.818.496%201.198l-.93%201.315L2.95%2013.89l1.312-.938c.38.205.787.38%201.224.497L5.746%2015h2.566l.263-1.578c.408-.117.817-.293%201.196-.497l1.315.935%201.81-1.812-.935-1.315c.203-.38.38-.76.495-1.2L14%209.303zm-7%201.404c-1.488%200-2.683-1.2-2.683-2.69S5.542%205.327%207%205.327c1.458%200%202.683%201.198%202.683%202.69%200%201.49-1.195%202.688-2.683%202.688z%22%20id%3D%22a%22%2F%3E%3C%2Fdefs%3E%3Cuse%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23808080%22%2F%3E%3Cuse%20transform%3D%22translate%280%2016%29%22%20xlink%3Ahref%3D%22%23a%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E%0A);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf16/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.svg?2015-02-05T19:28:20Z)!ie;height:16px;width:14px;float:right;cursor:pointer}.skin-vector #p-lang .uls-settings-trigger{ margin-top:3px}#p-lang .uls-settings-trigger:hover{background-position:right -16px}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:b203b2faf81b530a6f0701f8f97b1922 */
.mw-collapsible-toggle{float:right;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.mw-customtoggle,.mw-collapsible-toggle{cursor:pointer} caption .mw-collapsible-toggle{float:none} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:869aa9133c31e6040d4830b259da96a8 */
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.highlight{font-weight:bold}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:f8d0c6895ce3ae14434c16b8fca59432 */
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.25wmf16/resources/src/mediawiki.action/images/green-checkmark.png?2015-02-05T19:23:20Z)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:715591b8700882ee6213fb211807f35a */
.mw-ui-icon{position:relative;min-height:1.4em;min-width:1.4em}.mw-ui-icon.mw-ui-icon-element{text-indent:-999px;overflow:hidden;width:3.4em;min-width:3.4em;max-width:3.4em}.mw-ui-icon.mw-ui-icon-element:before{left:0;right:0;position:absolute;margin:0 1em}.mw-ui-icon.mw-ui-icon-after:after,.mw-ui-icon.mw-ui-icon-before:before,.mw-ui-icon.mw-ui-icon-element:before{background-position:50% 50%;float:left;display:block;background-repeat:no-repeat;background-size:100% auto;min-height:1.4em;content:''}.mw-ui-icon.mw-ui-icon-before:before{position:relative;width:1.4em;margin-right:1em}.mw-ui-icon.mw-ui-icon-after:after{position:relative;float:right;width:1.4em;margin-left:1em}.mw-ui-icon-ok.mw-ui-icon:after,.mw-ui-icon-ok.mw-ui-icon:before{background-image:url(//bits.wikimedia.org/static-1.25wmf16/resources/src/mediawiki.ui/components/images/ok.png?2015-02-05T19:23:20Z);background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2222%22%20height%3D%2222%22%3E%3Cpath%20d%3D%22M18.125%201.813l-10.5%2010.75-3.844-3.75L0%2012.719l7.72%207.452L22%205.625z%22%20fill%3D%22%23f0f0f0%22%2F%3E%3C%2Fsvg%3E%0A);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf16/resources/src/mediawiki.ui/components/images/ok.svg?2015-02-05T19:23:20Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2222%22%20height%3D%2222%22%3E%3Cpath%20d%3D%22M18.125%201.813l-10.5%2010.75-3.844-3.75L0%2012.719l7.72%207.452L22%205.625z%22%20fill%3D%22%23f0f0f0%22%2F%3E%3C%2Fsvg%3E%0A);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.25wmf16/resources/src/mediawiki.ui/components/images/ok.svg?2015-02-05T19:23:20Z)!ie}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:0d570773158a676c33e9572c54d975e4 */</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:black;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:ae3fa4570b5ac0c6cf7b3776c8ae4d6f */
.mw-mmv-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:1000;background-color:#000000}body.mw-mmv-lightbox-open{overflow-y:auto}body.mw-mmv-lightbox-open #mw-page-base,body.mw-mmv-lightbox-open #mw-head-base,body.mw-mmv-lightbox-open #mw-navigation,body.mw-mmv-lightbox-open #content,body.mw-mmv-lightbox-open #footer,body.mw-mmv-lightbox-open #globalWrapper // monobook{ display:none}body.mw-mmv-lightbox-open > *{ display:none}body.mw-mmv-lightbox-open > .mw-mmv-overlay,body.mw-mmv-lightbox-open > .mw-mmv-wrapper{display:block}.mw-mmv-filepage-buttons{margin-top:5px}.mw-mmv-filepage-buttons .mw-mmv-view-expanded,.mw-mmv-filepage-buttons .mw-mmv-view-config{display:block}.mw-mmv-filepage-buttons .mw-mmv-view-expanded.mw-ui-icon:before{background-image:url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%0A%3C%21--%20Created%20with%20Inkscape%20%28http%3A%2F%2Fwww.inkscape.org%2F%29%20--%3E%0A%0A%3Csvg%0A%20%20%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%0A%20%20%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%0A%20%20%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%0A%20%20%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%0A%20%20%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%0A%20%20%20version%3D%221.1%22%0A%20%20%20width%3D%22100%25%22%0A%20%20%20height%3D%22100%25%22%0A%20%20%20viewBox%3D%220%200%201024%20768%22%0A%20%20%20id%3D%22Layer_1%22%0A%20%20%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%0A%20%20%20%20%20id%3D%22metadata17%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%0A%20%20%20%20%20%20%20%20%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%0A%20%20%20%20%20%20%20%20%20%20%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%0A%20%20%20%20%20id%3D%22defs15%22%20%2F%3E%3Cg%0A%20%20%20%20%20id%3D%22g3%22%3E%3Cpolygon%0A%20%20%20%20%20%20%20points%3D%22851.2%2C71.6%20690.7%2C232.1%20650.6%2C191.8%20641%2C356.6%20805.8%2C347.3%20765.5%2C306.9%20926%2C146.4%20984.5%2C204.9%20997.6%2C0%20792.7%2C13.1%20%22%0A%20%20%20%20%20%20%20id%3D%22polygon5%22%0A%20%20%20%20%20%20%20style%3D%22fill%3A%23777777%22%20%2F%3E%3Cpolygon%0A%20%20%20%20%20%20%20points%3D%22769.6%2C89.3%20611.9%2C89.3%20682.8%2C160.1%20690.7%2C167.6%20%22%0A%20%20%20%20%20%20%20id%3D%22polygon7%22%0A%20%20%20%20%20%20%20style%3D%22fill%3A%23777777%22%20%2F%3E%3Cpath%0A%20%20%20%20%20%20%20d%3D%22m%20643.6%2C402.2%20-51.2%2C3%203%2C-51.2%209.4%2C-164.4%205.8%2C-100.3%20H%2026.4%20V%20768%20H%20909.5%20V%20387%20l%20-100.9%2C5.8%20-165%2C9.4%20z%20M%20813.9%2C678%20H%20113.6%20l%20207.2%2C-270.2%2031.5%2C-12.9%20195.7%2C204.9%20105.9%2C-63.2%20159.8%2C140.8%200.2%2C0.6%200%2C0%20z%22%0A%20%20%20%20%20%20%20id%3D%22path9%22%0A%20%20%20%20%20%20%20style%3D%22fill%3A%23777777%22%20%2F%3E%3Cpolygon%0A%20%20%20%20%20%20%20points%3D%22909.5%2C386.1%20909.5%2C228%20830.4%2C306.9%20838.2%2C314.8%20%22%0A%20%20%20%20%20%20%20id%3D%22polygon11%22%0A%20%20%20%20%20%20%20style%3D%22fill%3A%23777777%22%20%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E);background-image:url(//bits.wikimedia.org/static-1.25wmf16/extensions/MultimediaViewer/resources/mmv/img/expand.svg?2015-02-05T19:26:40Z)!ie}.mw-mmv-filepage-buttons .mw-mmv-view-config.mw-ui-icon:before{background-image:url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%0A%3C%21--%20Created%20with%20Inkscape%20%28http%3A%2F%2Fwww.inkscape.org%2F%29%20--%3E%0A%0A%3Csvg%0A%20%20%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%0A%20%20%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%0A%20%20%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%0A%20%20%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%0A%20%20%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%0A%20%20%20version%3D%221.1%22%0A%20%20%20width%3D%22100%25%22%0A%20%20%20height%3D%22100%25%22%0A%20%20%20viewBox%3D%220%200%201024%20768%22%0A%20%20%20id%3D%22Layer_1%22%0A%20%20%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%0A%20%20%20%20%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%0A%20%20%20%20%20%20%20%20%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%0A%20%20%20%20%20%20%20%20%20%20%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%0A%20%20%20%20%20id%3D%22defs7%22%20%2F%3E%3Cpath%0A%20%20%20%20%20d%3D%22M%20897%2C454.6%20V%20313.4%20L%20810.4%2C299%20c%20-6.4%2C-23.3%20-16%2C-45.7%20-27.3%2C-65.8%20L%20833.6%2C161.8%20734.2%2C61.6%20662.8%2C112.1%20C%20641.9%2C100.9%20620.3%2C91.2%20597%2C84.8%20L%20582.6%2C-1%20H%20441.4%20L%20427%2C85.6%20c%20-23.3%2C6.4%20-45.7%2C16%20-65.8%2C27.3%20L%20289.8%2C62.4%20189.5%2C161.9%20240%2C233.3%20c%20-11.2%2C20.9%20-20.9%2C42.5%20-27.3%2C66.6%20L%20127%2C313.4%20v%20141.2%20l%2085.8%2C14.4%20c%206.4%2C23.3%2016%2C45.7%2027.3%2C66.6%20l%20-50.5%2C71.4%2099.5%2C99.5%2071.4%2C-50.5%20c%2020.9%2C11.2%2042.5%2C20.9%2066.6%2C27.3%20l%2014.4%2C85.8%20h%20141.2%20l%2014.4%2C-86.6%20c%2023.3%2C-6.4%2045.7%2C-16%2065.8%2C-27.3%20l%2071.4%2C50.5%2099.5%2C-99.5%20-50.5%2C-71.4%20c%2011.2%2C-20.9%2020.9%2C-42.5%2027.3%2C-66.6%20L%20897%2C454.6%20z%20m%20-385%2C77%20C%20430.2%2C531.6%20364.4%2C465%20364.4%2C384%20364.4%2C302.2%20431%2C236.4%20512%2C236.4%20c%2081%2C0%20147.6%2C65.8%20147.6%2C147.6%200%2C81.8%20-65.8%2C147.6%20-147.6%2C147.6%20z%22%0A%20%20%20%20%20id%3D%22path3%22%0A%20%20%20%20%20style%3D%22fill%3A%23777777%22%20%2F%3E%3C%2Fsvg%3E);background-image:url(//bits.wikimedia.org/static-1.25wmf16/extensions/MultimediaViewer/resources/mmv/img/gear_gray.svg?2015-02-05T19:26:40Z)!ie;opacity:0.75}.mw-mmv-filepage-buttons .mw-mmv-view-config.mw-ui-icon:before:hover{opacity:1}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:2380ed82b17907f7a27a252aa6d5ce5c */</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="http://bits.wikimedia.org/ru.wikibooks.org/load.php?debug=false&lang=ru&modules=site&only=styles&skin=vector&*">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: ruwikibooks:resourceloader:filter:minify-css:7:8b031e7631b731d7c5f15abf29b55c16 */</style>
<script src="./Монадические комбинаторы парсеров — Викиучебник_files/load.php"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/load(1).php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Монадические_комбинаторы_парсеров","wgTitle":"Монадические комбинаторы парсеров","wgCurRevisionId":99634,"wgRevisionId":99634,"wgArticleId":2416,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Викиучебник:Кандидаты на удаление","Викиучебник:Просроченные подведения итогов по удалению страниц","Функциональное программирование"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Монадические_комбинаторы_парсеров","wgRelevantArticleId":2416,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":false,"publish":false},"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgVisualEditor":{"pageLanguageCode":"ru","pageLanguageDir":"ltr","svgMaxSize":4096,"namespacesWithSubpages":{"0":1,"6":0,"8":0,"1":true,"2":true,"3":true,"4":true,"5":true,"7":true,"9":true,"10":true,"11":true,"12":true,"13":true,"14":true,"15":true,"100":true,"101":true,"102":true,"103":true,"104":true,"105":true,"106":true,"107":true,"108":true,"109":true,"110":true,"111":true,"830":true,"831":true,"828":true,"829":true}},"wgPoweredByHHVM":true,"wgULSAcceptLanguageList":["ru-ru","ru","en-us","en"],"wgULSCurrentAutonym":"русский","wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgNoticeProject":"wikibooks"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"ru"});},{},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});},{},{},{});
/* cache key: ruwikibooks:resourceloader:filter:minify-js:7:115d09ffb88d9e770c8e4ad3962b675d */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","ext.centralauth.centralautologin","mmv.head","ext.visualEditor.viewPageTarget.init","ext.uls.init","ext.uls.interface","ext.centralNotice.bannerController","skins.vector.js"]);
}</script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/load(2).php"></script>
<link rel="dns-prefetch" href="http://meta.wikimedia.org/">
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/w/static-1.25wmf16/skins/Vector/csshover.min.htc")}</style><![endif]-->
<script src="./Монадические комбинаторы парсеров — Викиучебник_files/index.php" type="text/javascript"></script><script type="text/javascript" src="chrome-extension://phfplpepeojlgfgdfgfgfnmgakolcgoa/js/injected.js"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(1).php" type="text/javascript"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(2).php" type="text/javascript"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(3).php" type="text/javascript"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(4).php" type="text/javascript"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(5).php" type="text/javascript"></script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/index(6).php" type="text/javascript"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Монадические_комбинаторы_парсеров skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

							<div id="siteNotice"><div id="centralNotice"></div><!-- CentralNotice --></div>
						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="ru">Монадические комбинаторы парсеров</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">Материал из Викиучебника</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#mw-head">навигация</a>, 					<a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#p-search">поиск</a>
				</div>
				<div id="mw-content-text" lang="ru" dir="ltr" class="mw-content-ltr"><table class="metadata plainlinks ambox ambox-serious" style="background:#fee">
<tbody><tr>
<td class="ambox-image">
<div><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9A_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E" title="Викиучебник:К удалению"><img alt="Mail-mark-junk red.svg" src="./Монадические комбинаторы парсеров — Викиучебник_files/48px-Mail-mark-junk_red.svg.png" width="48" height="48" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/10/Mail-mark-junk_red.svg/72px-Mail-mark-junk_red.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/10/Mail-mark-junk_red.svg/96px-Mail-mark-junk_red.svg.png 2x" data-file-width="48" data-file-height="48"></a></div>
</td>
<td class="ambox-text"><b>Эта страница предлагается к удалению.</b>
<div style="font-size:smaller">Пояснение причин и соответствующее обсуждение вы можете найти на странице <span style="white-space: nowrap;"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9A_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E/%D0%9D%D0%BE%D1%8F%D0%B1%D1%80%D1%8C_2014#.D0.9C.D0.BE.D0.BD.D0.B0.D0.B4.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BA.D0.BE.D0.BC.D0.B1.D0.B8.D0.BD.D0.B0.D1.82.D0.BE.D1.80.D1.8B_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.BE.D0.B2" title="Викиучебник:К удалению/Ноябрь 2014">Викиучебник:К удалению/Ноябрь 2014</a>.</span><br>
Пока процесс обсуждения не завершён, статью можно попытаться улучшить, однако следует воздерживаться от переименований или немотивированного удаления содержания, подробнее см. <a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%A7%D1%82%D0%BE_%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C,_%D0%B5%D1%81%D0%BB%D0%B8_%D0%B2%D0%B0%D1%88_%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA_%D1%81%D1%82%D0%B0%D0%BB_%D0%BA%D0%B0%D0%BD%D0%B4%D0%B8%D0%B4%D0%B0%D1%82%D0%BE%D0%BC_%D0%BD%D0%B0_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5" title="Викиучебник:Что делать, если ваш учебник стал кандидатом на удаление" class="mw-redirect">руководство к дальнейшему действию</a>.<br>
Не снимайте пометку о выставлении на удаление до окончания обсуждения.
<hr>
<i><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%90" title="Викиучебник:А" class="mw-redirect">Администраторам</a>: <a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2" title="Служебная:Ссылки сюда/Монадические комбинаторы парсеров">ссылки сюда</a>, <a class="external text" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=history">история</a> (<a class="external text" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&diff=0">последнее изменение</a>), <a class="external text" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=delete&wpReason=%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BD%D0%BE+%5B%5B%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA%3A%D0%9A+%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E%2F%D0%9D%D0%BE%D1%8F%D0%B1%D1%80%D1%8C+2014%23%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B+%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2%5D%5D">удалить</a>.</i></div>
</td>
<td class="widthhack"></td>
</tr>
</tbody></table>
<center>
<table align="center" cellpadding="2" cellspacing="1" border="1" width="0" style="margin-right: 1em; margin-bottom: 0.5em; border: #99B3FF solid 1px; font-size: 9pt">
<tbody><tr>
<td colspan="2" align="center" nowrap="nowrap" style="background-color: #CCCCFF"><b>Информация об авторе</b></td>
</tr>
<tr align="left">
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Автор:</td>
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Грэм Хаттон (Graham Hutton)</td>
</tr>
<tr align="left">
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Место работы:</td>
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Университет Ноттингема, Великобритания</td>
</tr>
<tr align="left">
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Электронный адрес:</td>
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em"><a rel="nofollow" class="external text" href="mailto:gmh@cs.nott.ac.uk">gmh@cs.nott.ac.uk</a></td>
</tr>
<tr align="left">
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em">Адрес оригинала статьи:</td>
<td nowrap="nowrap" style="padding-left: 0.5em; padding-right: 0.5em"><a rel="nofollow" class="external text" href="http://www.cs.nott.ac.uk/~gmh">Личная страница Грэма Хаттона</a></td>
</tr>
</tbody></table>
</center>
<p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>Содержание</h2>
<span class="toctoggle">&nbsp;[<a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#" id="togglelink">убрать</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9F.D1.80.D0.B5.D0.B4.D0.B8.D1.81.D0.BB.D0.BE.D0.B2.D0.B8.D0.B5"><span class="tocnumber">1</span> <span class="toctext">Предисловие</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5"><span class="tocnumber">2</span> <span class="toctext">Введение</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9A.D0.BE.D0.BC.D0.B1.D0.B8.D0.BD.D0.B0.D1.82.D0.BE.D1.80.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B"><span class="tocnumber">3</span> <span class="toctext">Комбинаторные парсеры</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.A2.D0.B8.D0.BF.D1.8B_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.BE.D0.B2"><span class="tocnumber">3.1</span> <span class="toctext">Типы парсеров</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9F.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B"><span class="tocnumber">3.2</span> <span class="toctext">Примитивные парсеры</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9F.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BC.D0.B1.D0.B8.D0.BD.D0.B0.D1.82.D0.BE.D1.80.D1.8B"><span class="tocnumber">3.3</span> <span class="toctext">Парсерные комбинаторы</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9F.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B_.D0.B8_.D0.BC.D0.BE.D0.BD.D0.B0.D0.B4.D1.8B"><span class="tocnumber">4</span> <span class="toctext">Парсеры и монады</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9C.D0.BE.D0.BD.D0.B0.D0.B4.D0.B0_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.B0"><span class="tocnumber">4.1</span> <span class="toctext">Монада парсера</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#.D0.9D.D0.90_.D0.9F.D0.95.D0.A0.D0.95.D0.92.D0.9E.D0.94"><span class="tocnumber">5</span> <span class="toctext">НА ПЕРЕВОД</span></a></li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.B4.D0.B8.D1.81.D0.BB.D0.BE.D0.B2.D0.B8.D0.B5">Предисловие</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=1" title="Редактировать раздел «Предисловие»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>В функциональном программировании популярным подходом к построению рекурсивных синтаксических анализаторов является моделирование парсеров как функций и определение функций высшего порядка (комбинаторов), которые снабжены грамматическими конструкциями, такими как упорядочение, выбор и повторение. Такие парсеры образуют примеры монад, алгебраических структур из математики, которые доказали полезность при исследовании большого числа вычислительных задач. Цель данной статьи состоит в том, чтобы дать пошаговое руководство к унарному методу построения функциональных парсеров, и объяснить некоторые преимущества использования монад. Эта статья может быть рассмотрена как первое введение в использование монад в программировании.</p>
<h2><span class="mw-headline" id=".D0.92.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D0.B5">Введение</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=2" title="Редактировать раздел «Введение»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>В функциональном программировании популярным подходом к построению рекурсивных синтаксических анализаторов является моделирование парсеров как функций и определение функций высшего порядка (комбинаторов), которые снабжены грамматическими конструкциями, такими как упорядочение, выбор и повторение. Основная идея берет начало в книге Burge о методах рекурсивного программирования (Burge, 1975), и была сделана популярной в функциональном программировании Wadler (1985), Hutton (1992), Fokker (1995), и другими. Комбинаторы предоставляют быстрый и простой метод для создания функциональных парсеров (синтаксических анализаторов). Кроме того, метод имеет преимущества перед генераторами функциональных парсеров, такими как Ratatosk (Mogensen, 1993) и Happy (Gill &amp; Marlow, 1995). Этот метод имеет полную мощность функционального языка, доступную для определения новых комбинаторов для приложений (Ландин, 1966).</p>
<p>Раньше было известно (Wadler, 1990), что парсеры формируют пример монад, алгебраических структур из математики, которые доказали полезность при исследовании большого числа вычислительных задач. Интересное с математической точки зрения постижение унарной природы парсера приносит также практическую выгоду. Например, использование унарного упорядочивающего комбинатора для парсера позволяет избежать беспорядочных манипуляций с кортежами результатов, представленных в более ранних работах. Более того, использование унарных вложенных нотаций делает парсеры более компактными и понятными для чтения.</p>
<p>Рассматривая монадный метод дальше, монады парсеров могут быть выражены в модульном виде через две более простые монады. Непосредственная выгода состоит в том, что основные парсерные комбинаторы не нужно больше определять явно. Предпочтительно они возникают автоматически как специальный случай поднимающих операций монады от основной монады m к некоторой другой монаде параметризованной над m. Это означает так же, что если мы изменяем природу парсера модификацией основной монады (например, ограничивая парсер только на создание одного результата), тогда новые комбинаторы для модифицированной монады парсера также возникают через поднимающую конструкцию.</p>
<p>Цель данной статьи состоит в том, чтобы дать пошаговое руководство в монадном методе построения функциональных парсеров, и объяснить некоторые преимущества использования монад. Большинство материала уже известно. Наш вклад состоит в организации материала в консультативную статью, введение новых комбинаторов для обработки лексических вопросов без отдельного лексического анализатора и новом методе выполнения побочных правил.</p>
<p>Боле глубокое знакомство с ФП оказалось бы весьма полезно при чтении этой статьи, но использование некоторых черт Gofer (Jones, 1995b) - нашего языка реализации - будет объяснено. Любой другой ленивый функциональный язык программирования, поддерживающий (многопараметрические) конструкторы классов и использование вложенной нотации монад, - так же бы подошел. Никакое предшествующее знание парсерных комбинаторов или монад не принимается. На самом деле, эта статья может также рассмотрена как первое введение в использование монад в программировании. Библиотека монадных парсерных комбинаторов, взятая из этой статьи доступна через World-Wide-Web.</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.B1.D0.B8.D0.BD.D0.B0.D1.82.D0.BE.D1.80.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B">Комбинаторные парсеры</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=3" title="Редактировать раздел «Комбинаторные парсеры»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Приступим к рассмотрению основных идей комбинаторного синтаксического анализа. Практически мы определим типы парсеров, три простых парсера, и два примитивных комбинатора для строительства больших парсеров.</p>
<h3><span class="mw-headline" id=".D0.A2.D0.B8.D0.BF.D1.8B_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.BE.D0.B2">Типы парсеров</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=4" title="Редактировать раздел «Типы парсеров»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Давайте рассмотрим парсеры как функции, которые берут на входе строку символов и выдают некоторый тип дерева в качестве результата, таким образом, что дерево представляет грамматическую структуру строки:</p>
<pre><code>type Parser = String -&gt; Tree</code>
</pre>
<p>В общем, тем не менее, синтаксический анализатор может не поглощать всю входную строку, так что даже если результатом парсера является просто дерево, все равно мы возвращаем необработанный конец входной строки. Таким образом, модифицируем тип парсера следующим образом:</p>
<pre><code>type Parser = String -&gt; (Tree,String)</code>
</pre>
<p>Также парсер может завершиться неудачно при разборе входной строки. Чем только сообщать об ошибках выполнения, когда они будут происходить, лучше использовать парсер, возвращающий список пар, а не одиночную пару, с соглашением, что пустой список обозначает неудачное выполнение парсера, и одиночный список обозначает успешное выполнение:</p>
<pre><code>type Parser = String -&gt; [(Tree,String)]</code>
</pre>
<p>Имея явное представление неудачного выполнения и возврат необработанного конца входной строки возможно определить комбинаторы для построения частей парсера из меньших парсеров. Возврат списка результатов открывает возможность возвращать более одного результата, если входная строка может быть разобрана более чем одним способом, что является следствием неоднозначности основной грамматики.</p>
<p>Наконец, различные парсеры могут возвращать различные типы деревьев, так что полезно абстрагировать специфичный тип Tree деревьев, и сделать тип возвращаемого значения в параметре типа Parser:</p>
<pre>type Parser a = String -&gt; [(a,String)]
</pre>
<p>Этот тип парсеров мы будем использовать в оставшейся части статьи. Можно пойти дальше и абстрагировать тип String символов, но у нас сейчас нет потребности в таком обобщении.</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B">Примитивные парсеры</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=5" title="Редактировать раздел «Примитивные парсеры»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Три простых парсера, определенные в этом разделе, являются строительными блоками комбинаторного синтаксического анализа. Первый парсер — result v, который выполняется без поглощения входной строки и возвращает единственный результат v:</p>
<pre>result :: a -&gt; Parser a
result v = \inp -&gt; [(v,inp)]
</pre>
<p>Выражение вида \x -&gt; e называется ламбда-абстракцией и обозначает функцию, которая берет на входе x и возвращает значение выражения e. Таким образом result v - функция, которая берет входную строку inp и возвращает единственный список [(v,inp)].С таким же успехом эта функция может быть определена как result v inp = [(v,inp)], но предпочтительнее предыдущее определение (в котором аргумент inp находится в теле определения), так как оно более соответствует типу result&nbsp;:: a -&gt; Parser a, который утверждает что result - функция, которая берет на входе единственный параметр и возвращает синтаксический анализатор.</p>
<p>Также парсер zero всегда завершается неудачно, вне зависимости от входной строки:</p>
<pre>zero :: Parser a
zero = \inp -&gt; []
</pre>
<p>Наш последний примитив - item, который успешно поглощает первый символ во входной строке, если она не пуста, и завершается неудачно в противном случае:</p>
<pre>item :: Parser Char
item = \inp -&gt; case inp of
[] -&gt; []
(x:xs) -&gt; [(x,xs)]
</pre>
<h3><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BC.D0.B1.D0.B8.D0.BD.D0.B0.D1.82.D0.BE.D1.80.D1.8B">Парсерные комбинаторы</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=6" title="Редактировать раздел «Парсерные комбинаторы»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Простые синтаксические анализаторы, определенные выше, не очень полезны сами по себе. В этом разделе мы рассмотрим, как они могут склеиваться вместе для формирования более полезных синтаксических анализаторов. Мы берем основу из БНФ нотации для специфицированных грамматик, в которых большие грамматики построены кусочно из меньших грамматик, с использованием оператора упорядочения, обозначаемого при помощи соединения, и оператора выбора, обозначаемый вертикальной чертой |. Мы определим соответствующие операторы для комбинирования парсеров, таким образом, что структура наших синтаксических анализаторов тесно следует из структуры основных грамматик. В более ранних (не монадных) вариантах комбинаторного синтаксического анализа (Wadler, 1985; Hutton, 1992; Fokker, 1995), упорядочение парсеров обычно записывались через комбинаторы:</p>
<pre>seq :: Parser a -&gt; Parser b -&gt; Parser (a,b)
p `seq` q = \inp -&gt; [((v,w),inp<i>) | (v,inp') &lt;- p inp, (w,inp</i>) &lt;- q inp']
</pre>
<p>которые применяют один парсер после другого, объединяя результаты парсеров в пару. Инфиксная нотация p `seq` q является синтаксическим сахаром для seq p q; любая функция от двух аргументов может быть использована как инфиксный оператор в таком случае при заключении ее имени в обратные кавычки. На первый взгляд, комбинатор seq может показаться естественным примитивом композиции. На практике, тем не менее, применение seq приводит к парсерам с вложенными кортежами в качестве результата, которыми сложно управлять.</p>
<p>Проблему вложенных кортежей значений можно избежать , используя унарный комбинатор упорядочения (обычно обозначаемый как bind) , который объединяет упорядочение парсеров с обработкой их результирующих значений:</p>
<pre>bind :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p `bind` f = \inp -&gt; concat [f v inp' | (v,inp') &lt;- p inp]
</pre>
<p>Определение для комбинатора bind может быть интерпретировано следующим образом. Прежде всего, парсер р применяется ко входной строке, выдавая список (value,string) пар. Если f - это функция, которая берет значение и возвращает парсер, она может быть приложена к каждому значению (и к необработанной входной строке ) в свою очередь. В результате получается список списков (value,string) пар, который затем может быть преобразован, используя операцию конкатенации.</p>
<p>Комбинатор bind позволяет избежать проблемы вложенных кортежей результатов, потому что результаты первого парсера непосредственно доступны для обработки вторым, а не спариваются с другими результатами для последующей обработки. Типичный парсер, построенный с использованием bind имеет следующую структуру:</p>
<pre>p1 `bind` \x1 -&gt;
p2 `bind` \x2 -&gt;
...
pn `bind` \xn -&gt;
result (f x1 x2 ... xn)
</pre>
<p>и может быть интерпретирован следующим образом: применим парсер p1 и обозначим результат через x1, затем применим парсер p2 и обозначим результат через x2,..., потом применим парсер pn и обозначим результат через xn, и затем объединим результаты в одно значение применением функции f. Например, комбинатор seq может быть определен следующим образом:</p>
<pre>p `seq` q = p `bind` \x -&gt;
q `bind` \y -&gt;
result (x,y)
</pre>
<p>(С другой стороны bind не может быть определен через seq.) Используя комбинатор bind, мы теперь можем определить некоторые простые, но очень полезные парсеры. Вспомните, что парсер item поглощает безусловно один символ. На практике нас интересует поглощение некоторых специфичных символов. По этой причине мы используем item для определения комбинатора sat, который берет на входе предикат (функцию с булевым значением) и выдает парсер, который поглощает символ, если тот удовлетворяет предикату, и завершает выполнение неудачно в противном случае:</p>
<pre>sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = item `bind` \x -&gt;
  if p x then result x else zero x
</pre>
<p>Следует отметить, что если item выполняется неудачно ( в случае если входная строка пустая ), тогда то же происходит с sat p, потому что легко заметить, что zero `bind` f = zero для любой функции f подходящего типа. На самом деле это уравнение не характерно для парсеров: оно справедливо для произвольной монады с нулем. Монады и их связь с парсерами будут обсуждены в следующем разделе. Используя sat, мы можем определить синтаксические анализаторы для специфических символов, цифр, букв в нижнем регистре, букв в верхнем регистре:</p>
<pre>char :: Char -&gt; Parser Char
char x = sat (\y -&gt; x == y)

digit :: Parser Char
digit = sat (\x -&gt; '0' &lt;= x &amp;&amp; x &lt;= '9')

lower :: Parser Char
lower = sat (\x -&gt; 'a' &lt;= x &amp;&amp; x &lt;= 'z')

upper :: Parser Char
upper = sat (\x -&gt; 'A' &lt;= x &amp;&amp; x &lt;= 'Z')
</pre>
<p>Например, применение парсера upper ко входной строке "Hello" выдает единственный правильный результат [('H',"ello")], т.е. парсер выдает в качестве результата 'H', а "ello" – это необработанный суффикс входной строки. С другой стороны, применение парсера lower к строке "Hello" выдаст результат [], так как'H'- не буква в нижнем регистре.</p>
<p>В качестве другого пример использования bind рассмотрим парсер, который принимает две буквы в нижнем регистре, возвращает строку длиной в два символа:</p>
<pre>lower `bind` \x -&gt;
lower `bind` \y -&gt;
result [x,y]
</pre>
<p>Применение этого синтаксического анализатора к строке "abcd" выдает результат [("ab","cd")].Применение того же синтаксического анализатора к "aBcd" возвращает [], поскольку даже если начальный символ 'a' может быть поглощен первым парсером lower, следующий символ 'B' не может быть поглощен вторым парсером lower.</p>
<p>Конечно, вышеуказанный синтаксический анализатор для двух символов в последовательности может быть обобщен до синтаксического анализатора для строк с произвольным числом символов в нижнем регистре. Когда длина разбираемой строки не известна заранее, такой синтаксический анализатор естественно будет определяться рекурсивно, используя оператор выбора между разбором единственного символа и рекурсией или разбором пустого списка и последующим завершением. Подходящий комбинатор выбора для парсеров, plus, - определяется следующим образом:</p>
<pre>plus :: Parser a -&gt; Parser a -&gt; Parser a
p `plus` q = \inp -&gt; (p inp ++ q inp)
</pre>
<p>То есть, оба парсера- аргумента p и q применяются к одной и той же входной строке, и их результирующие списки конкатенируются для формирования единственный результирующего списка. Отметим, что не требовалось, чтобы p и q принимали непересекающиеся множества строк: если оба синтаксических анализатора завершаться успешно при разборе входной строки, тогда будет возвращено одно результирующее значение, отражающее различные способы, которыми входная строка может быть разобрана.</p>
<p>В качестве примера использования plus, некоторые ранее рассмотренные парсеры теперь могут быть объединены для образования парсеров для букв и буквенных-числовых символов:</p>
<pre>letter :: Parser Char
letter = lower `plus` upper

alphanum :: Parser Char
alphanum = letter `plus` digit
</pre>
<p>Парсер для слов (последовательностей букв) определяется так:</p>
<pre>word :: Parser String
word = neWord `plus` result ""
           where
                 neWord = letter `bind` \x -&gt;
                                  word `bind` \xs -&gt;
                                  result (x:xs)
</pre>
<p><code>word</code> разбирает непустое слово ( единственный символ следующий за словом, рекурсивно вызывая word), в этом случае два результата объединяются для формирования строки, или выполняет разбор пустого слова и возвращает пустую строку.</p>
<p>Например, применение word ко входной строке "Yes!" выдает результат [("Yes","!"),("Ye","s!"), ("Y","es!"), ("","Yes!")]. Первый результат, ("Yes","!"), - ожидаемый результат: строка символов "Yes" обработана, и необработанная часть - "!". В последующих результатах, все меньшее количество символов обработано. Такое поведение возникает поскольку оператор выбора plus - недетерминированный: обе альтернативы могут быть рассмотрены, даже если первая альтернатива вполне успешна. Таким образом, в каждом применении letter, есть всегда возможность просто закончить выполнение грамматического разбора, даже если остались необработанные символы во входной строке.</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D1.81.D0.B5.D1.80.D1.8B_.D0.B8_.D0.BC.D0.BE.D0.BD.D0.B0.D0.B4.D1.8B">Парсеры и монады</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=7" title="Редактировать раздел «Парсеры и монады»">править</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Позже мы определим множество полезных парсерных комбинаторов через простые парсеры и комбинаторы, которые только что определены. Но сначала мы становим наше внимание на монадной природе комбинаторных парсеров.</p>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.BD.D0.B0.D0.B4.D0.B0_.D0.BF.D0.B0.D1.80.D1.81.D0.B5.D1.80.D0.B0">Монада парсера</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=8" title="Редактировать раздел «Монада парсера»">править</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Таким образом, мы определили следующие операции над парсерами:</p>
<pre>result :: a -&gt; Parser a
bind :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
</pre>
<p>Обобщение специфичных случаев Parser до немного произвольного Конструктор типа M дает понятие монады: монада является конструктором типа M ( функция от типов к типам), вместе с операциями result и bind следующих типов:</p>
<pre>result :: a -&gt; M a
bind :: M a -&gt; (a -&gt; M b) -&gt; M b
</pre>
<p>Таким образом, парсеры формируют монаду, для которой M является конструктором типа Parser, и result и bind определены выше. Технически, две операции монады должны также удовлетворять некоторым алгебраическим свойствам, но здесь мы не касаемся таких свойств. Смотрите (Wadler, 1992a; Wadler, 1992b) за дополнительной информацией.</p>
<p>Читатели, знакомые с категориальным определением монад могут ожидать две операции: map&nbsp;:: (a -&gt; b) -&gt; (M a -&gt; M b) и join&nbsp;:: M (M a) -&gt; M a вместо одного оператора bind. Тем не менее, наше определение является эквивалентом категориального и имеет преимущество в том, что bind является более удобным для унарного программирования, чем map и join.</p>
<p>Парсеры не являются единственным примером монады. На самом деле, мы увидим позже как монада парсера может быть переопределена через две простые монады. Это поднимает вопрос о том, что делать с присваиванием имен монадным комбинаторам result и bind. В функциональных языках, основанных на системе типов Hindley - Milner (например, Miranda1 и Standard ML) невозможно использовать одинаковые имена для комбинаторов различных монад. Предпочтительно, использовать различные имена, как например, resultM и bindM, для комбинаторов каждой монады M.</p>
<p>Гофер, однако, расширяет систему типов Hindley - Milner перегружающим механизмом , который разрешает использовать одно и то же имя для комбинаторов различных монад. При этом перегружающем механизме, подходящая монада в каждом случае использования имени вычисляется автоматически с помощью логического вывода типа. Перегрузка в Gofer выполнена с использованием классов (Jones, 1995c). Класс для монад может быть объявлен следующим образом:</p>
<pre>class Monad m where
    result :: a -&gt; m a
    bind :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>Это определение можно сформулировать следующим образом: конструктор типа m является членом класса Monad, если он содержит операторы result и bind соответствующих типов. Факт, что m должен быть конструктором типа (а не просто типом) вытекает из его использования в типах для операций. Сейчас конструктор типа Parser может быть получен из класса Monad с использованием result и bind, описанных в предыдущем разделе:</p>
<pre>instance Monad Parser where
   -- result :: a -&gt; Parser a
   result v = \inp -&gt; [(v,inp)]
</pre>
<pre>   -- bind :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
   p `bind` f = \inp -&gt; concat [f v out | (v,out) &lt;- p inp]
</pre>
<p><br>
Остановимся кратко на некоторых технических особенностях Gofer.Во-первых синонимы типа такого, как Parser должны быть обеспечены всеми своими аргументами. Следовательно, рассмотренный выше пример не является совсем правильным кодом Gofer, поскольку Parser был использован в первой строчке без аргумента. Проблема легко решается (переопределим Parser, используя data вместо type, или как ограниченный синоним типа), но для простоты в этой статье мы допустим, что синонимы типа могут быть частично применены. Во-вторых, синтаксис Gofer не позволяет явно задавать типы описанных функций при объявлении сущностей. Но для ясности мы включаем такие типы в комментарии. Рассмотрим сейчас следующие операции над парсерами:</p>
<pre>zero :: Parser a
plus :: Parser a -&gt; Parser a -&gt; Parser a
</pre>
<p>Обобщая снова частные случая конструктора типа Parser, мы приходим к нотации монады через zero и plus, которая может быть инкапсулирована, используя систему классов Gofer следующим образом:</p>
<pre>class Monad m =&gt; Monad0Plus m where
    zero :: m a
    (++) :: m a -&gt; m a -&gt; m a
</pre>
<p>То есть, конструктор типа m является членом класса Monad0Plus, если он - член класса Monad (то есть, содержит result и bind) и если также содержит операторы zero и (++) соответствующих типов. Конечно, два дополнительных оператора должны также удовлетворить некоторым алгебраическим свойствам; эти обсуждается в (Wadler, 1992a; Wadler, 1992b). Заметим также, что использование (++) предпочтительнее чем plus, мы увидим позже примеры списков, которые формируют монаду для которой операция plus похожа на операцию добавления (++). Так как Parser является монадой, он может быть преобразован в монаду с zero и plus, используя следующее определение:</p>
<p><br></p>
<pre>instance Monad0Plus Parser where
  -- zero :: Parser a
  zero = \inp -&gt; []
</pre>
<pre>  -- (++) :: Parser a -&gt; Parser a -&gt; Parser a
 p  ++ q = \inp -&gt; (p inp ++ q inp)
</pre>
<p>3.2. Вложенный синтаксис монады Пока мы видели одно преимущество осознания монадной природы синтаксических анализаторов: монадный комбинатор упорядочения bind оперирует результирующими значениями лучше, чем стандартный комбинатор упорядочения seq. В этом разделе, мы рассмотрим другое преимущество монадного подхода, а именно, что вложенный синтаксис монады может быть использован, чтобы сделать синтаксические анализаторы более компактными и легко читаемыми. Как упомянуто выше, много синтаксических анализаторов будет иметь в качестве структуры последовательность binds, сопровожденную единственным вызовом result:</p>
<pre>p1 `bind` \x1 -&gt;
p2 `bind` \x2 -&gt;
...
pn `bind` \xn -&gt;
result (f x1 x2 ... xn)
</pre>
<p>Gofer имеет нотацию для определения синтаксических анализаторов такого вида, выражая их в более привлекательном виде:</p>
<pre>[ f x1 x2 ... xn | x1 &lt;- p1
 , x2 &lt;- p2
                , ...
                , xn &lt;- pn ]
</pre>
<p>Фактически, эта нотация не специфична для парсеров, но может быть использована с любой монадой (Jones, 1995c). Читатель мог обратить внимание на сходство с вложенной нотацией списка, поддерживаемой многими функциональными языками. Wadler (1990) первым заметил, что эта вложенная нотация специфична не только для списков, но имеет смысл для произвольной монады. Оказывается, алгебраические свойства требуемые для монадных операций точно такие же, что и те, которые требуются для нотации, чтобы та имела смысл. К сведению, Gofer - первый язык, который поддерживает вложенную нотацию монады Wadler. Использование этой нотации может сделать парсер более удобочитаемым, и мы будем использовать эту нотацию в остальной части этой статьи. В качестве первого примера использования вложенной нотации, мы определим синтаксический анализатор для распознавания специфичной строки, возвращающий саму строку как результат:</p>
<pre>string :: String -&gt; Parser String
string "" = [""]
string (x:xs) = [x:xs | _ &lt;- char x, _ &lt;- string xs]
</pre>
<p>То есть, если строка, которую нужно разобрать, является пустой, мы просто возвращаем пустую строку в качестве результата; [""] - только вложенный синтаксис монады для result "". В противном случае, мы выполняем грамматический разбор первого символа в строке, используя char, затем выполняем грамматический разбор остальных символов используя рекурсивный вызов string. Без помощи вложенной нотации, вышеуказанное определение выглядит следующим образом:</p>
<pre>string :: String -&gt; Parser String
string "" = result ""
string (x:xs) = char x `bind` \_ -&gt;
                      string xs `bind` \_ -&gt;
                      result (x:xs) 
</pre>
<p>Парсер string xs выполняется неудачно, если только префикс данной строки xs есть во входных данных. Например, применяя парсер string "hello" к входным данным "hello there" дает успешный результат [("hello"," there")]. С другой стороны, применение того же парсера к "helicopter" выполняется неудачно с результатом [], хотя префикс "hel" есть во входной строке. Во вложенной нотации списка, мы не просто ограничены генераторами, которые связывают переменные с величинами, но можем также использовать булеву «защиту», которая ограничивает значения связанных переменных. Например, функция negs, которая выбирается все отрицательные числа из списка целых может быть выражена следующим образом:</p>
<pre>negs :: [Int] -&gt; [Int]
negs xs = [x | x &lt;- xs, x &lt; 0]
</pre>
<p><br>
В этом случае, выражение x &lt; 0является защитой, которая ограничивает переменную x (связанную генератором x &lt;- xs), значениями меньше нуля. Wadler (1990) заметил, что использование защиты имеет смысл для произвольной монады с нулем. Вложенная нотация монады в Gofer поддерживает использование защиты. Например, определим комбинатор:</p>
<pre>sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = item `bind` \x -&gt;
          if p x then result x else zero
</pre>
<p>который может быть определен более компактно, используя вложение с защитой:</p>
<pre>sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = [x | x &lt;- item, p x]
</pre>
<p>Завершая этот раздел, отметим, что есть другая нотация, которая может быть использована для упрощения монадных программ: так называемая нотация do (Jones, 1994; Jones &amp; Launchbury, 1994). Например, используя эту нотацию, комбинаторы string и sat могут быть определены следующим образом:</p>
<pre>string :: String -&gt; Parser String
string "" = do { result "" }
string (x:xs) = do { char x ; string xs ; result (x:xs) }
</pre>
<pre>sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do { x &lt;- item ; if (p x) ; result x }
</pre>
<p>Нотация do имеет пару преимуществ перед вложенной нотацией монады: мы не ограничены в выражениях монады, которые заканчиваются с использованием result; и генераторы формы _ &lt;- e, которые не связывают переменные, могут быть укорочены с использованием e. Нотация do поддерживается Gofer, но выражения монады, содержащие парсеры, обычно заканчиваются с использованием result (для вычисления величины результата парсера), так что дополнительная общность не является действительно необходимой в этом случае. По этой причине, и для упрощения, в этой статье мы используем только вложенную нотацию. Тем не менее, это было бы несложно перевести наши определения в нотацию do.</p>
<p><br></p>
<p>4. комбинаторы для повторения Генераторы парсеров такие, как, например, Lex и Yacc (Aho et al., 1986) для производства синтаксических анализаторов написанных на C, и Ratatosk (Mogensen, 1993) и Happy (Gill &amp; Marlow, 1995) для производства синтаксических анализаторов написанных на Haskell, обычно предлагают фиксированный набор комбинаторов для описания грамматики. С другой стороны, с методом построения парсеров как представлено в этой статье, множество комбинаторов полностью расширяемо: парсеры являются величинами первого класса, и у нас есть полная мощность функционального языка в нашем расположении для определения нужных комбинаторов для конкретных приложений. В этом разделе мы определим комбинаторы для множества общих моделей повторения. Эти комбинаторы не являются специфичными для парсеров, но могут быть использованы с произвольной монадой с zero и plus . Для ясности, тем не менее, мы специализируем типы комбинаторов в случае парсеров. В последующих разделах мы введем комбинаторы для других целей, включая лексические вопросы обработки и сторонние правила Gofer.</p>
<p>4.1. Простые повторения Ранее мы определили парсер word для поглощения нуля или большего количества букв во входной строке. Используя вложенную нотацию монады, определение выглядит следующим образом:</p>
<pre>word :: Parser String
word = [x:xs | x &lt;- letter, xs &lt;- word] ++ [""]
</pre>
<p>Мы можем легко представить себе множество других синтаксических анализаторов, структура которых похожа на word. Например, синтаксические анализаторы для строк цифр или строк пробелов могли бы быть определены таким же образом, единственное отличие в том, что компонентный парсер letter будет заменен на digit или char ' '. Для чтобы избежания определения множества других синтаксических анализаторов с аналогичной структурой, мы абстрагируем образец рекурсии в word и определим общий комбинатор, many, который выполняет грамматический разбор последовательности объектов. Комбинатор many применяет p нуль или больше раз ко входной строке. Результаты каждого применения p возвращаются в список:</p>
<pre>many :: Parser a -&gt; Parser [a]
many p = [x:xs | x &lt;- p, xs &lt;- many p] ++ [[]]
</pre>
<p>Различные парсеры могут быть получены заменой различных парсеров - аргументов p. Например, парсер word может определен как many letter, и другие синтаксические анализаторы, упоминаемые выше, - как many digit и many (char ' '). Подобно тому, как исходный текстовый синтаксический анализатор возвращает множественный результат (количество результатов уменьшается в зависимости от числа обработанных букв во входной строке), то же самое делает many p. Конечно, в большинстве случаев нас будет интересовать только первый грамматический разбор many p, в котором p успешно применен необходимое количество раз. Мы вернемся к этому вопросу в следующем разделе, когда будем рассматривать эффективность парсеров. В качестве другого применения many, мы можем определить синтаксический анализатор для идентификаторов. Для простоты, будем считать идентификатором последовательность буквенно-числовых символов, первым символом в которой является буквой в нижнем регистре. Будет легко расширить определение для обработки дополнительных символов, например, символа подчеркивания или обратных кавычек.</p>
<pre>ident :: Parser String
ident = [x:xs | x &lt;- lower, xs &lt;- many alphanum]
</pre>
<p>Иногда мы будем рассматривать только непустые последовательности объектов. Поэтому определяем специальный комбинатор many1 через many:</p>
<pre>many1 :: Parser a -&gt; Parser [a]
many1 p = [x:xs | x &lt;- p, xs &lt;- many p]
</pre>
<p>Например, применение many1 (char 'a') ко входной строке "aaab" дает результат [("aaa","b"), ("aa","ab"), ("a","aab")],который является таким же, как и для many (char'a'), кроме того, что конечной пары ("", "aaab") больше нет. Заметим также, что many1 p может выполниться неудачно, тогда, как many p всегда выполняется успешно. Используя many1, мы можем определить парсер для натуральных чисел&nbsp;:</p>
<pre>nat :: Parser Int
nat = [eval xs | xs &lt;- many1 digit]
 where
  eval xs = foldl1 op [ord x - ord '0' | x &lt;- xs]
  m `op` n = 10*m + n
</pre>
<p>Еще, nat может быть использован для определения парсера для целых чисел&nbsp;:</p>
<pre>int :: Parser Int
int = [-n | _ &lt;- char '-', n &lt;- nat] ++ nat
</pre>
<p>Лучший способ для определения парсера int состоит в следующем. Сначала пытаемся выполнить грамматический разбор символа отрицания '-'. Если это выполняется успешно, тогда возвращается функция отрицания как результат грамматического разбора; в противном случае возвращается функция тождества. Конечный шаг состоит в разборе натурального числа и использовании функции, возвращенной в результате грамматического разбора символа '-'для модифицирования результирующего числа:</p>
<pre>int :: Parser Int
int = [f n | f &lt;- op, n &lt;- nat]
 where
     op = [negate | _ &lt;- char '-'] ++ [id]
</pre>
<p>4.2. Повторения с разделителями Комбинатор many выполняет грамматический разбор последовательности объектов. Теперь мы рассмотрим чуть более общий образец повторения, в который включены разделители между объектами. Рассмотрим проблему синтаксического анализа непустого списка целых чисел, как например, [1,-42,17]. Такой синтаксический анализатор может быть определен через комбинатор many следующим образом:</p>
<pre>ints :: Parser [Int]
ints = [n:ns | _ &lt;- char '['
                , n &lt;- int
                , ns &lt;- many [x | _ &lt;- char ',', x &lt;- int]
                , _ &lt;- char ']']
</pre>
<p>Как и в предыдущем разделе для синтаксического анализатора word, мы можем представить множество других синтаксических анализаторов с аналогичной ints структурой, так что будет полезно абстрагировать шаблон повторения и определить универсальный комбинатор, который мы назовем sepby1. Комбинатор sepby1 похож на many1 в том, что он распознает непустые последовательности, выданные парсером p, но отличается тем, что примеры p разделены синтаксическим анализатором sep, чьи результирующие значения игнорируются:</p>
<pre>sepby1 :: Parser a -&gt; Parser b -&gt; Parser [a]
p `sepby1` sep = [x:xs | x &lt;- p
                      , xs &lt;- many [y | _ &lt;- sep, y &lt;- p]]
</pre>
<p>Отметим, что тот факт, что результаты парсера sep игнорируются, отражен в типе комбинатора sepby1&nbsp;: парсер sep дает результаты типа b, но этот тип не встречается в типе [a] результатов комбинатора. Теперь ints может быть определен в более компактной форме:</p>
<pre>ints = [ns | _ &lt;- char '['
          , ns &lt;- int `sepby1` char ','
          , _ &lt;- char ']']
</pre>
<p>Фактически мы можем пойти немного дальше. Заключение в скобки синтаксических анализаторов другими синтаксическими анализаторами, чьи результаты игнорируются - в случае, рассмотренном выше, заключающими в скобки синтаксическими анализаторами являются - char '[' и char ']'- встречается довольно часто для определения соответствующего комбинатора:</p>
<pre>bracket :: Parser a -&gt; Parser b -&gt; Parser c -&gt; Parser b
bracket open p close = [x | _ &lt;- open, x &lt;- p, _ &lt;- close]
</pre>
<p>Сейчас можем определить ints следующим образом:</p>
<pre>ints = bracket (char '[')
   (int `sepby1` char ',')
              (char ']')
</pre>
<p>Наконец, когда many1 был определен через many, комбинатор sepby (для возможных пустых последовательностей), естественно определяется через sepby1:</p>
<pre>sepby :: Parser a -&gt; Parser b -&gt; Parser [a]
p `sepby` sep = (p `sepby1` sep) ++ [[]]
</pre>
<p>4.3 Повторения со значимыми разделителями Комбинатор sepby выполняет синтаксический анализ последовательностей объектов, разделенных текстом, который может быть проигнорирован. В этом конечном разделе о повторениях, мы рассмотрим более общий случай, в котором сами разделители являются значимыми. Комбинаторы, определенные в этом разделе созданы Fokker (1995). Рассмотрим проблему синтаксического анализа простых арифметических выражений таких как 1+2-(3+4), построенных из натуральных чисел, используя сложение, вычитание, и скобки. Два арифметических оператора лево ассоциативны (таким образом, например, 1-2-3 должно быть разобрано как (1-2)-3), и имеют один и тот же приоритет. Стандартная грамматика BNF для таких выражений записывается следующим образом:</p>
<pre>expr ::= expr addop factor | factor
addop ::= +| -
factor ::= nat | ( expr )
</pre>
<p>Эта грамматика может быть непосредственно переводена в комбинаторный парсер:</p>
<pre>expr :: Parser Int
addop :: Parser (Int -&gt; Int -&gt; Int)
factor :: Parser Int
</pre>
<pre>expr = [f x y | x &lt;- expr, f &lt;- addop, y &lt;- factor] ++ factor
</pre>
<pre>addop = [(+) | _ &lt;- char '+'] ++ [(-) | _ &lt;- char '-']
</pre>
<pre>factor = nat ++ bracket (char '(') expr (char ')')
</pre>
<p>Фактически, вместо того, чтобы возвращать некоторый тип дерева грамматического разбора, синтаксический анализатор expr действительно вычисляет значение арифметического выражения: синтаксический анализатор addop возвращает функцию в качестве результирующего значения, которая используется для комбинирования результирующих значений, порожденных при синтаксическом разборе аргументов в операторы. Конечно, тем не менее, есть некоторые проблемы с синтаксическим анализатором expr, определенным выше. То, что операторы лево ассоциативны учтено в том, что expr лево-рекурсивен ( первое,что он делает - рекурсивно вызывает самого себя). Таким образом, expr не совершает никакого прогресса, и следовательно не завершается. Известно, эта проблема незавершения для синтаксических анализаторов может быть решена заменой левой рекурсии итерацией. Смотря на грамматику expr, мы видим что выражение является последовательностью factors, разделенной addops. Таким образом синтаксический анализатор для выражений может быть переопределен используя many следующим образом:</p>
<pre>expr = [... | x &lt;- factor
            , fys &lt;- many [(f,y) | f &lt;- addop, y &lt;- factor]]
</pre>
<p>Это решает проблему о незавершении, но все еще остается проблема заполнения части "..." нового определения, которое вычисляет величину выражения. Полагаем теперь, что входной строкой является "1-2+3-4". Затем после синтаксического анализа с использованием expr, переменная x будет равна 1 и fys будет списком [((-),2), ((+),3), ((-),4)]. Он может быть уменьшен до единственного значения 1-2+3-4 = ((1-2)+3)-4 = -2 складывая: встроенная функция foldl – такова, что, например, foldl g [b,c,d,e] = (( `g b) `g c) `g d) `g e. В настоящем случае, нам нужно брать g как функцию \x (f,y) -&gt; f x y, и а как целое x:</p>
<pre>expr = [foldl (\x (f,y) -&gt; f x y) x fys
          | x &lt;- factor
          , fys &lt;- many [(f,y) | f &lt;- addop, y &lt;- factor]]
</pre>
<p>Теперь, например, применение expr ко входной строке "1+2-(3+4)" дает результат [(-4,""), (3,"-(3+4)", (1,"+2-(3+4)")], как и следовало ожидать. Продолжая дальше обобщение, мы можем абстрагировать шаблон повторения в expr и определить новый комбинатор. Комбинатор chainl1 выполняет грамматический разбор непустых последовательностей объектов, разделенных операторами, которые левоассоциативны:</p>
<pre>chainl1 :: Parser a -&gt; Parser (a -&gt; a -&gt; a) -&gt; Parser a
p `chainl1` op = [foldl (\x (f,y) -&gt; f x y) x fys
                  | x &lt;- p
                  , fys &lt;- many [(f,y) | f &lt;- op, y &lt;- p]]
</pre>
<p>Таким образом, наш синтаксический анализатор для выражений может быть теперь записан следующим образом:</p>
<pre>expr = factor `chainl1` addop
</pre>
<pre>addop = [(+) | _ &lt;- char '+'] ++ [(-) | _ &lt;- char '-']
</pre>
<pre>factor = nat ++ bracket (char '(') expr (char ')')
</pre>
<p>Большинство операторных парсеров будут иметь аналогичную addop структуру, так что будет полезно абстрагировать комбинатор для построения таких синтаксических анализаторов:</p>
<pre>ops :: [(Parser a, b)] -&gt; Parser b
ops xs = foldr1 (++) [[op | _ &lt;- p] | (p,op) &lt;- xs]
</pre>
<p>Встроенная функция foldr1 - такова что, например, foldr1 g [a,b,c,d] = `g (b `g (c `g d)). Она определена для любого непустого списка. В вышеуказанном случае потом, foldr1 помещает оператор выбора (++) между каждым синтаксическим анализатором в списке. Используя ops, наш парсер addop может теперь быть определен&nbsp;:</p>
<pre>addop = ops [(char '+', (+)), (char '-', (-))]
</pre>
<p>Возможная неэффективность в определении комбинатора chainl1 заключается в конструкции промежуточного списка fys. Это может быть решено использованием прямого рекурсивного определения chainl1, которое не использует foldl и many, используя накапливающий параметр, для создания конечного результата:</p>
<pre>chainl1 :: Parser a -&gt; Parser (a -&gt; a -&gt; a) -&gt; Parser a
p `chainl1` op = p `bind` rest
 where
  rest x = (op `bind` \f -&gt;
   p `bind` \y -&gt;
    rest (f x y)) ++ [x]
</pre>
<p>Это определение имеет стандартный способ чтения операций. Синтаксический анализатор p `chainl1 op сначала выполняет грамматический разбор p, результирующее значение становится начальным аккумулятором для функции rest. Затем выполняется грамматический разбор оператора и единственного p. Если это завершается успешно, аккумулятор и результат p объединяются, используя функцию f, возвращенную из синтаксического анализа оператора, и результирующее значение становится новым аккумулятором при синтаксическом анализе остальной последовательности (используя рекурсивный вызов rest). В противном случае, последовательность завершается, и аккумулятор возвращается. В качестве другого интересного применения chainl1, мы можем переопределить наш ранее определенный синтаксический анализатор nat для натуральных чисел таким образом, что он не создает промежуточный список цифр. В этом случае, парсер op не осуществляет никакой синтаксический анализ, но возвращает функцию, которая объединяет натурал и цифру:</p>
<pre>nat :: Parser Int
nat = [ord x - ord '0' | x &lt;- digit] `chainl1` [op]
 where
  m `op` n = 10*m + n
</pre>
<p>Естественно, мы можем также определить комбинатор chainr1, который выполняет грамматический разбор непустых последовательностей символов, разделенных операторами, которые не лево, а право ассоциативны. Для простоты, мы только даем прямое рекурсивное определение:</p>
<pre>chainr1 :: Parser a -&gt; Parser (a -&gt; a -&gt; a) -&gt; Parser a
p `chainr1` op =
  p `bind` \x -&gt;
     [f x y | f &lt;- op, y &lt;- p `chainr1` op] ++ [x]
</pre>
<p>То есть, p `chainr1` op сначала выполняет грамматический разбор единственного p. Затем он пытается выполнить грамматический разбор оператора и остальной части последовательности (используя рекурсивный вызов chainr1). Если он завершается успешно, пара результатов из первого p и остальной части последовательности объединяются, используя функцию f возвращенную из синтаксического анализа оператора. В противном случае, последовательность завершается, и результат из p возвращается. Как пример использования chainr1, мы расширим наш синтаксический анализатор для арифметических выражений для того, чтобы оперировать возведением в степень; этот оператор имеет более высокий приоритет чем предшествующие два оператора, и право ассоциативен:</p>
<pre>expr = term `chainl1` addop
</pre>
<pre>term = factor `chainr1` expop
</pre>
<pre>factor = nat ++ bracket (char '(') expr (char ')')
</pre>
<pre>addop = ops [(char '+', (+)), (char '-', (-))]
expop = ops [(char '^', (^))]
</pre>
<p>Для полноты, мы также определим комбинаторы chainl и chainr, которые имеют такое же поведение, что и chainl1 и chainr1, за исключением того что они могут также не поглощать никакой входной строки, в этом случае данная величина v возвращается как результат:</p>
<pre>chainl :: Parser a -&gt; Parser (a -&gt; a -&gt; a) -&gt; a -&gt; Parser a
chainl p op v = (p `chainl1` op) ++ [v]
</pre>
<pre>chainr :: Parser a -&gt; Parser (a -&gt; a -&gt; a) -&gt; a -&gt; Parser a
chainr p op v = (p `chainr1` op) ++ [v]
</pre>
<p>В итоге , chainl и chainr предоставляют простой способ построения синтаксических анализаторов для грамматик наподобие выражения. Использование этих комбинаторов позволяет избежать потребности в преобразованиях для удаления левой рекурсии в грамматике, что в противном случае привело бы к незавершению синтаксического анализатора. Они также позволяют избежать потребности в левом разложении на элементарные операции грамматики, что в противном случае привело к необязательному возвращению в исходное состояние; мы возвратимся к этому в следующем разделе.</p>
<p>5. эффективность парсеров Использование комбинаторов - простой и гибкий метод построения синтаксических анализаторов. Тем не менее, мощь комбинаторов - на практике, их способности возвращаться в исходное состояние и возвращать множественные результаты - может провести к синтаксическим анализаторам с неожиданными пространственными и временными характеристиками, если не быть осторожным. В этом разделе, мы расскажем о некоторых простых методах, которые могут быть использованы для улучшения эффективности синтаксических анализаторов. Читателям заинтересовавшимся в их дальнейшем развитии предлагаю обратиться к Rojemo's thesis (1995), который содержит главу об использовании инструментальных средств, ориентированных на кучу, в оптимизации парсерных комбинаторов.</p>
<p>5.1. Левостороннее разложение на множители Рассмотрим простую проблему синтаксического анализа и вычисления двух натуральных чисел разделенных знаком сложения `+', или знаком вычитания `-'. Эта спецификация может переводиться непосредственно в следующий синтаксический анализатор:</p>
<pre>eval :: Parser Int
eval = add ++ sub
      where
        add = [x+y | x &lt;- nat, _ &lt;- char '+', y &lt;- nat]
        sub = [x-y | x &lt;- nat, _ &lt;- char '-', y &lt;- nat]
</pre>
<p>Этот синтаксический анализатор дает правильный, но неэффективный результат. Например, при синтаксическом анализе строки "123-456" число 123 сначала будет разобрано парсером add, который завершится неудачно поскольку нет символа `+', следующего за числом. Правильный грамматический разбор будет найден при возвращении в исходное состояние входной строки, и выполнении грамматического разбора числа 123 снова, на этот раз парсером sub. Конечно, способ избежать возможности возвращения в исходное состояние и повторения синтаксического анализа состоит в левостороннем разложении на множители парсера eval . То есть, начальное использование nat в компонентных синтаксических анализаторах add и sub должно разложено на множители:</p>
<pre>eval = [v | x &lt;- nat, v &lt;- add x ++ sub x]
where
        add x = [x+y | _ &lt;- char '+', y &lt;- nat]
        sub x = [x+y | _ &lt;- char '-', y &lt;- nat]
</pre>
<p>Эта новая версия eval дает те же результаты что и первоначальная, но не требует никаких возвращений в исходное состояние. Используя новый eval, строка "123-456" может теперь быть разобраны за меньшее время. Фактически мы можем пойти немного дальше, и выполнить правостороннее разложение на множители в остальных случаях использования nat в add и sub. Это не улучшает эффективность вычисления, но вероятно дает очищающий синтаксический анализатор:</p>
<pre>eval = [f x y | x &lt;- nat
             , f &lt;- ops [(char '+', (+)), (char '-', (-))]
             , y &lt;- nat]
</pre>
<p>На практике, большинство случаев где левоcтороннее разложение на множители синтаксического анализатора необходимо для улучшения эффективности относятся к синтаксическим анализаторам для некоторого типа выражений. В таких случаях, разложение на множители вручную синтаксического анализатора не требуется, поскольку синтаксические анализаторы наподобие выражений мо гут быть построены используя комбинатор chain из предыдущего раздела, которая уже инкапсулирует необходимое левостороннее разложение на множители. Девиз этого раздела состоит в следующем: возвращение в исходное состояние является мощным средством, но оно не должно использоваться в качестве замены в целях безопасности проектирования синтаксических анализаторов.</p>
<p>5.2. Улучшение ленивости Вспомним определение комбинатора many:</p>
<pre>many :: Parser a -&gt; Parser [a]
many p = [x:xs | x &lt;- p, xs &lt;- many p] ++ [[]]
</pre>
<p>Например, применение many (char 'a') ко входной строке "aaab" дает результат [("aaa","b"), ("aa","ab"), ("a","aab"),("","aaab")]. Так как Gofer является ленивым, мы могли ожидать, что символы a в первом результате "aaa" будут доступными поочередно, пока они поглощаются из входной строки. На практике никакая часть результата "aaa" не будет произведена, пока весь все символы a не будут поглощены. Другими словами, many не такой ленивый как мы могли ожидать. Но имеет ли это значение? Да, потому что является обычным в функциональном программировании положиться на ленивость для избежания создания больших промежуточных структур (Hughes, 1989). Как отмечено Wadler (1985; 1992b), для решения проблемы с many необходимо сделать явным тот факт, что парсер many p всегда выполняется успешно. (Даже если p непосредственно всегда будет выполняться неудачно, то many p все равно будет завершаться успешно с пустым списком в качестве результирующего значения). В этом цель мощи комбинаторов:</p>
<pre>force :: Parser a -&gt; Parser a
force p = \inp -&gt; let x = p inp in
                 (fst (head x), snd (head x)) : tail x
</pre>
<p>Предполагая, что парсер p выполнятся всегда успешно, парсер force p ведет себя как p, за исключением того, что, прежде чем будет выполнен парсинг входной строки, результат парсера сразу приводится к виду (┴,┴):┴, где ┴ - неопределенная величина. Используя force, комбинатор many может быть переопределен следующим образом:</p>
<pre>many :: Parser a -&gt; Parser [a]
many p = force ([x:xs | x &lt;- p, xs &lt;- many p] ++ [[]])
</pre>
<p>Использование force гарантирует, что many p и все его рекурсивные вызовы возвращают по крайней мере один результат. Новое определение many теперь имеет ожидаемое с точки зрения ленивости поведение. Например, применение many (char 'a') к частично- определенной строке 'a':┴ дает частично - определенный результат ('a':┴,┴):┴. В противовес, старая версия many выдает результат для этого примера - полностью неопределенную величину ┴. Некоторые читатели могли удивиться почему force определен, используя следующие функции выбора, а не сопоставление с образцом?</p>
<pre>fst :: (a,b) -&gt; a      head :: [a] -&gt; a
snd :: (a,b) -&gt; b      tail :: [a] -&gt; [a]
</pre>
<p>Ответ в том, что в зависимости от семантики образцов на конкретном языке реализации, определение force, используя образцы, может не иметь ожидаемое поведение с точки зрения ленивости.</p>
<p>5.3. Ограничения количества результатов Рассмотрим синтаксический анализ натурального числа, или если никакое такое число не представлено возвращение нуля в качестве результата. Первое приближение такого синтаксического анализатора может быть следующим:</p>
<pre>number :: Parser Int
number = nat ++ [0]
</pre>
<p>Тем не менее, оно не имеет требуемого поведения. Например, применение number ко входной строке "hello" дает правильный результат [(0,"hello")]. С другой стороны, применение number к "123" дает результат [(123,""), (0,"123")], тогда, когда мы ожидали получить единственный результат [(123,"")]. Одно решение вышеуказанной проблемы состоит в использовании детерминированных парсерных комбинаторов (смотри раздел 7.5) - все синтаксические анализаторы, построенные, используя такие комбинаторы, ограничены конструкцией на создания самое большее одного результата. Более общее решение, тем не менее, должно сохранить гибкость недетерминированных комбинаторов, но обеспечивать средства, позволяющие сделать явным тот факт, что нас интересует только первый результат, произведенный такими синтаксическими анализаторами, как например, number. Это цель комбинатора first:</p>
<pre>first :: Parser a -&gt; Parser a
first p = \inp -&gt; case p inp of
                  [] -&gt; []
                  (x:xs) -&gt; [x]
</pre>
<p>Cинтаксический анализатор first p имеет то же поведение что и p, кроме того, что возвращается только первый результат. Используя first, мы можем определить детерминированную версию (+++) через стандартный комбинатор выбора (++) для синтаксических анализаторов:</p>
<pre>(+++) :: Parser a -&gt; Parser a -&gt; Parser a
p +++ q = first (p ++ q)
</pre>
<p>Замена (++) на (+++) в number дает желаемое поведение. Кроме использования для подтверждения корректного поведения парсеров, (+++)может также использоваться для улучшения их эффективность. Так, например, рассмотрим синтаксический анализатор, который принимает строку "yellow" или "orange":</p>
<pre>colour :: Parser String
colour = p1 ++ p2
   where
           p1 = string "yellow"
           p2 = string "orange"
</pre>
<p>Вспомним теперь поведение комбинатора выбора (++): он берет строку, применяет оба парсера - аргумента к этой строке и конкатенирует результирующие списки. Таким образом, в красочном примере, если p1 успешно применен, тогда p2 все еще будет применяться к той же строке, даже если гарантировано выполнится неудачно. Это неэффективность может быть устранена используя (+++), который гарантирует, что, если p1 выполняется успешно, тогда p2 никогда не применяется:</p>
<pre>colour = p1 +++ p2
where
  p1 = string "yellow"
  p2 = string "orange"
</pre>
<p>Если мы знаем, что синтаксический анализатор формы p ++ q детерминирован (возвращает, самое большее, одну результирующую величину), тогда p +++ q имеет такое же поведение, но более эффективное: если p выполняется успешно, тогда q никогда не применяется. В остальной части этой статьи по большей части будет использоваться комбинатор выбора (+++). Из-за большей эффективности, в библиотеках комбинаторов, которые прилагаются в этой статье, комбинатор повторения из предшествующего раздела определен используя (+++) а не (++). Мы завершаем этот раздел, задавая вопрос почему first определен сопоставлением с образцом, а не используя функцию выбора take&nbsp;:: Int -&gt; [a] -&gt; [a] (где, например, take 3 "parsing" = "par"):</p>
<pre>first p = \inp -&gt; take 1 (p inp)
</pre>
<p>Ответ относится к поведению с точки зрения ленивости. Для того, чтобы разобраться в проблеме, давайте раскроем использование take в вышеуказанном определении:</p>
<pre>first p = \inp -&gt; case p inp of
                  [] -&gt; []
                  (x:xs) -&gt; x : take 0 xs
</pre>
<p>Когда подвыражение take 0 xs вычислено, оно дает []. Тем не менее, с точки зрения ленивости это вычисление будет приостановлено до тех пор, пока величина не потребуется. Но суть в том, что список xs может храниться в памяти в течение некоторого времени, когда фактически, он может спокойно быть отвергнутым немедленно. Это пример утечки пространства. Определение first, используя сопоставление с образцом, не позволяет решить эту проблему.</p>
<h1><span class="mw-headline" id=".D0.9D.D0.90_.D0.9F.D0.95.D0.A0.D0.95.D0.92.D0.9E.D0.94">НА ПЕРЕВОД</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&section=9" title="Редактировать раздел «НА ПЕРЕВОД»">править</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>6 Handling lexical issues Traditionally, a string to be parsed is not supplied directly to a parser, but is �rst passed through a lexical analysis phase (or lexer) that breaks the string into a sequence of tokens (Aho et al., 1986). Lexical analysis is a convenient place to remove white-space (spaces, newlines, and tabs) and comments from the input string, and to distinguish between identi�ers and keywords. Since lexers are just simple parsers, they can be built using parser combinators, as discussed by Hutton (1992). However, as we shall see in this section, the need for a separate lexer can often be avoided (even for substantial grammars such as that for Gofer), with lexical issues being handled within the main parser by using some special purpose combinators. 6.1 White-space, comments, and keywords We begin by de�ning a parser that consumes white-space from the beginning of a string, with a dummy value () returned as result: spaces&nbsp;:: Parser () spaces = [() | _ &lt;- many1 (sat isSpace)] where isSpace x = (x == ' ') || (x == '\n') || (x == '\t') Similarly, a single-line Gofer comment can be consumed as follows: comment&nbsp;:: Parser () comment = [() | _ &lt;- string "--" , _ &lt;- many (sat (\x -&gt; x /= '\n'))] We leave it as an exercise for the reader to de�ne a parser for consuming multi-line Gofer comments f- ... -g, which can be nested. After consuming white-space, there may still be a comment left to consume from the input string. Dually, after a comment there may still be white-space. Thus we are motivated to de�ned a special parser that repeatedly consumes white-space and comments until no more remain: junk&nbsp;:: Parser () junk = [() | _ &lt;- many (spaces +++ comment)] Note that while spaces and comment can fail, the junk parser always succeeds. We de�ne two combinators in terms of junk: parse removes junk before applying a given parser, and token removes junk after applying a parser: parse&nbsp;:: Parser a -&gt; Parser a parse p = [v | _ &lt;- junk, v &lt;- p] token&nbsp;:: Parser a -&gt; Parser a token p = [v | v &lt;- p, _ &lt;- junk] With the aid of these two combinators, parsers can be modi�ed to ignore whitespace and comments. Firstly, parse is applied once to the parser as a whole, ensuring that input to the parser begins at a signi�cant character. And secondly, token is applied once to all sub-parsers that consume complete tokens, thus ensuring that the input always remains at a signi�cant character. Examples of parsers for complete tokens are nat and int (for natural numbers and integers), parsers of the form string xs (for symbols and keywords), and ident (for identi�ers). It is useful to de�ne special versions of these parsers | and more generally, special versions of any user-de�ned parsers for complete tokens | that encapsulate the necessary application of token: natural&nbsp;:: Parser Int natural = token nat integer&nbsp;:: Parser Int integer = token int symbol&nbsp;:: String -&gt; Parser String symbol xs = token (string xs) identifier&nbsp;:: [String] -&gt; Parser String identifier ks = token [x | x &lt;- ident, not (elem x ks)] Note that identifier takes a list of keywords as an argument, where a keyword is a string that is not permitted as an identi�er. For example, in Gofer the strings \data" and \where" (among others) are keywords. Without the keyword check, parsers de�ned in terms of identifier could produce unexpected results, or involve unnecessary backtracking to construct the correct parse of the input string. To illustrate the use of the new combinators given above, let us de�ne a parser for simple �-expressions extended with a \let" construct for local de�nitions. Parsed expressions will be represented in Gofer as follows: data Expr = App Expr Expr -- application | Lam String Expr -- lambda abstraction | Let String Expr Expr -- local definition | Var String -- variable Now a parser expr&nbsp;:: Parser Expr can be de�ned by: expr = atom `chainl1` [App] atom = lam +++ local +++ var +++ paren lam = [Lam x e | _ &lt;- symbol "\\" , x &lt;- variable , _ &lt;- symbol "-&gt;" , e &lt;- expr] local = [Let x e e' | _ &lt;- symbol "let" , x &lt;- variable , _ &lt;- symbol "=" , e &lt;- expr , _ &lt;- symbol "in" , e' &lt;- expr] var = [Var x | x &lt;- variable] paren = bracket (symbol "(") expr (symbol ")") variable = identifier ["let","in"] Note how the expr parser handles white-space and comments by using the symbol parser in place of string and char. Similarly, the keywords \let" and \in" are handled by using identifier to de�ne the parser for variables. Finally, note how applications (f e1 e2 ... en) are parsed in the form (((f e1) e2) ... ) by using the chainl1 combinator. 7 Factorising the parser monad Up to this point in the article, combinator parsers have been our only example of the notion of a monad. In this section we de�ne a number of other monads related to the parser monad, leading up to a modular reformulation of the parser monad in terms of two simpler monads (Jones, 1995a). The immediate bene�t is that, as we shall see, the basic parser combinators no longer need to be de�ned explicitly. Rather, they arise automatically as a special case of lifting monad operations from a base monad m to a certain other monad parameterised over m. This also means that, if we change the nature of parsers by modifying the base monad (for example, limiting parsers to producing at most one result), new combinators for the modi�ed monad of parsers are also de�ned automatically. 7.1 The exception monad Before starting to de�ne other monads, it is useful to �rst focus brie y on the intuition behind the use of monads in functional programming (Wadler, 1992a). The basic idea behind monads is to distinguish the values that a computation can produce from the computation itself. More speci�cally, given a monad m and a type a, we can think of m a as the type of computations that yield results of type a, with the nature of the computation captured by the type constructor m. The combinators result and bind (with zero and (++) if appropriate) provide a means to structure the building of such computations: result&nbsp;:: m a bind&nbsp;:: m a -&gt; (a -&gt; m b) -&gt; m b zero&nbsp;:: m a (++)&nbsp;:: m a -&gt; m a -&gt; m a From a computational point of view, result converts values into computations that yield those values; bind chains two computations together in sequence, with results of the �rst computation being made available for use in the second; zero is the trivial computation that does nothing; and �nally, (++) is some kind of choice operation for computations. Consider, for example, the type constructor Maybe: data Maybe a = Just a | Nothing We can think of a value of type Maybe a as a computation that either succeeds with a value of type a, or fails, producing no value. Thus, the type constructor Maybe captures computations that have the possibility to fail. De�ning the monad combinators for a given type constructor is usually just a matter of making the \obvious de�nitions" suggested by the types of the combinators. For example, the type constructor Maybe can be made into a monad with a zero and plus using the following de�nitions: instance Monad Maybe where -- result&nbsp;:: a -&gt; Maybe a result x = Just x -- bind&nbsp;:: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (Just x) `bind` f = f x Nothing `bind` f = Nothing instance Monad0Plus Maybe where -- zero&nbsp;:: Maybe a zero = Nothing -- (++)&nbsp;:: Maybe a -&gt; Maybe a -&gt; Maybe a Just x ++ y = Just x Nothing ++ y = y That is, result converts a value into a computation that succeeds with this value; bind is a sequencing operator, with a successful result from the �rst computation being available for use in the second computation; zero is the computation that fails; and �nally, (++) is a (deterministic) choice operator that returns the �rst computation if it succeeds, and the second otherwise. Since failure can be viewed as a simple kind of exception, Maybe is sometimes called the exception monad in the literature (Spivey, 1990). 7.2 The non-determinism monad A natural generalisation of Maybe is the list type constructor []. While a value of type Maybe a can be thought of as a computation that either succeeds with a single result of type a or fails, a value of type [a] can be thought of as a computation that has the possibility to succeed with any number of results of type a, including zero (which represents failure). Thus the list type constructor [] can be used to capture non-deterministic computations. Now [] can be made into a monad with a zero and plus: instance Monad [] where -- result&nbsp;:: a -&gt; [a] result x = [x] -- bind&nbsp;:: [a] -&gt; (a -&gt; [b]) -&gt; [b] [] `bind` f = [] (x:xs) `bind` f = f x ++ (xs `bind` f) instance Monad0Plus [] where -- zero&nbsp;:: [a] zero = [] -- (++)&nbsp;:: [a] -&gt; [a] -&gt; [a] [] ++ ys = ys (x:xs) ++ ys = x&nbsp;: (xs ++ ys) That is, result converts a value into a computation that succeeds with this single value; bind is a sequencing operator for non-deterministic computations; zero always fails; and �nally, (++) is a (non-deterministic) choice operator that appends the results of the two argument computations. 7.3 The state-transformer monad Consider the (binary) type constructor State: type State s a = s -&gt; (a,s) Values of type State s a can be interpreted as follows: they are computations that take an initial state of type s, and yield a value of type a together with a new state of type s. Thus, the type constructor State s obtained by applying State to a single type s captures computations that involve state of type s. We will refer to values of type State s a as stateful computations. Now State s can be made into a monad: instance Monad (State s) where -- result&nbsp;:: a -&gt; State s a result v = \s -&gt; (v,s) -- bind&nbsp;:: State s a -&gt; (a -&gt; State s b) -&gt; State s b st `bind` f = \s -&gt; let (v,s') = st s in f v s' That is, result converts a value into a stateful computation that returns that value without modifying the internal state, and bind composes two stateful computations in sequence, with the result value from the �rst being supplied as input to the second. Thinking pictorially in terms of boxes and wires is a useful aid to becoming familiar with these two operations (Jones &amp; Launchbury, 1994). The state-transformer monad State s does not have a zero and a plus. However, as we shall see in the next section, the parameterised state-transformer monad over a given based monad m does have a zero and a plus, provided that m does. To allow us to access and modify the internal state, a few extra operations on the monad State s are introduced. The �rst operation, update, modi�es the state by applying a given function, and returns the old state as the result value of the computation. The remaining two operations are de�ned in terms of update: set replaces the state with a new state, and returns the old state as the result; fetch returns the state without modifying it. update&nbsp;:: (s -&gt; s) -&gt; State s s set&nbsp;:: s -&gt; State s s fetch&nbsp;:: State s s update f = \s -&gt; (s, f s) set s = update (\_ -&gt; s) fetch = update id In fact State s is not the only monad for which it makes sense to de�ne these operations. For this reason we encapsulate the extra operations in a class, so that the same names can be used for the operations of di�erent monads: class Monad m =&gt; StateMonad m s where update&nbsp;:: (s -&gt; s) -&gt; m s set&nbsp;:: s -&gt; m s fetch&nbsp;:: m s set s = update (\_ -&gt; s) fetch = update id This declaration can be read as follows: a type constructor m and a type s are together a member of the class StateMonad if m is a member of the class Monad, and if m is also equipped with update, set, and fetch operations of the speci�ed types. Moreover, the fact that set and fetch can be de�ned in terms of update is also re ected in the declaration, by means of default de�nitions. Now because State s is already a monad, it can be made into a state monad using the update operation as de�ned earlier: instance StateMonad (State s) s where -- update&nbsp;:: (s -&gt; s) -&gt; State s s update f = \s -&gt; (s, f s) 7.4 The parameterised state-transformer monad Recall now our type of combinator parsers: type Parser a = String -&gt; [(a,String)] We see now that parsers combine two kinds of computation: non-deterministic computations (the result of a parser is a list), and stateful computations (the state is the string being parsed). Abstracting from the speci�c case of returning a list of results, the Parser type gives rise to a generalised version of the State type constructor that applies a given type constructor m to the result of the computation: type StateM m s a = s -&gt; m (a,s) Now StateM m s can be made into a monad with a zero and a plus, by inheriting the monad operations from the base monad m: instance Monad m =&gt; Monad (StateM m s) where -- result&nbsp;:: a -&gt; StateM m s a result v = \s -&gt; result (v,s) -- bind&nbsp;:: StateM m s a -&gt; -- (a -&gt; StateM m s b) -&gt; StateM m s b stm `bind` f = \s -&gt; stm s `bind` \(v,s') -&gt; f v s' instance Monad0Plus m =&gt; Monad0Plus (StateM m s) where -- zero&nbsp;:: StateM m s a zero = \s -&gt; zero -- (++)&nbsp;:: StateM m s a -&gt; StateM m s a -&gt; StateM m s a stm ++ stm' = \s -&gt; stm s ++ stm' s That is, result converts a value into a computation that returns this value without modifying the internal state; bind chains two computations together; zero is the computation that fails regardless of the input state; and �nally, (++) is a choice operation that passes the same input state through to both of the argument computations, and combines their results. In the previous section we de�ned the extra operations update, set and fetch for the monad State s. Of course, these operations can also be de�ned for the parameterised state-transformer monad StateM m s. As previously, we only need to de�ne update, the remaining two operations being de�ned automatically via default de�nitions: instance Monad m =&gt; StateMonad (StateM m s) s where -- update&nbsp;:: Monad m =&gt; (s -&gt; s) -&gt; StateM m s s update f = \s -&gt; result (s, f s) 7.5 The parser monad revisited Recall once again our type of combinator parsers: type Parser a = String -&gt; [(a,String)] This type can now be re-expressed using the parameterised state-transformer monad StateM m s by taking [] for m, and String for s: type Parser a = StateM [] String a But why view the Parser type in this way? The answer is that all the basic parser combinators no longer need to be de�ned explicitly (except one, the parser item for single characters), but rather arise as an instance of the general case of extending monad operations from a type constructor m to the type constructor StateM m s. More speci�cally, since [] forms a monad with a zero and a plus, so does State [] String, and hence Gofer automatically provides the following combinators: result&nbsp;:: a -&gt; Parser a bind&nbsp;:: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b zero&nbsp;:: Parser a (++)&nbsp;:: Parser a -&gt; Parser a -&gt; Parser a Moreover, de�ning the parser monad in this modular way in terms of StateM means that, if we change the type of parsers, then new combinators for the modi�ed type are also de�ned automatically. For example, consider replacing type Parser a = StateM [] String a by a new de�nition in which the list type constructor [] (which captures nondeterministic computations that can return many results) is replaced by the Maybe type constructor (which captures deterministic computations that either fail, returning no result, or succeed with a single result): data Maybe a = Just a | Nothing type Parser a = StateM Maybe String a Since Maybe forms a monad with a zero and a plus, so does the re-de�ned Parser type constructor, and hence Gofer automatically provides result, bind, zero, and (++) combinators for deterministic parsers. In earlier approaches that do not exploit the monadic nature of parsers (Wadler, 1985; Hutton, 1992; Fokker, 1995), the basic combinators would have to be re-de�ned by hand. The only basic parsing primitive that does not arise from the monadic structure of the Parser type is the parser item for consuming single characters: item&nbsp;:: Parser Char item = \inp -&gt; case inp of [] -&gt; [] (x:xs) -&gt; [(x,xs)] However, item can now be re-de�ned in monadic style. We �rst fetch the current state (the input string); if the string is empty then the item parser fails, otherwise the �rst character is consumed (by applying the tail function to the state), and returned as the result value of the parser: item = [x | (x:_) &lt;- update tail] The advantage of the monadic de�nition of item is that it does not depend upon the internal details of the Parser type. Thus, for example, it works equally well for both the non-deterministic and deterministic versions of Parser. 8 Handling the o�side rule Earlier (section 6) we showed that the need for a lexer to handle white-space, comments, and keywords can be avoided by using special combinators within the main parser. Another task usually performed by a lexer is handling the Gofer o�side rule. This rule allows the grouping of de�nitions in a program to be indicated using indentation, and is usually implemented by the lexer inserting extra tokens (concerning indentation) into its output stream. In this section we show that Gofer's o�side rule can be handled in a simple and natural manner without a separate lexer, by once again using special combinators. Our approach was inspired by the monadic view of parsers, and is a development of an idea described earlier by Hutton (1992). 8.1 The o�side rule Consider the following simple Gofer program: a = b + c where b = 10 c = 15 - 5 d = a * 2 It is clear from the use of indentation that a and d are intended to be global de�nitions, with b and c local de�nitions to a. Indeed, the above program can be viewed as a shorthand for the following program, in which the grouping of de�nitions is made explicit using special brackets and separators: { a = b + c where { b = 10</p>
<dl>
<dt>c = 15 - 5 }</dt>
<dt>d = a * 2 }</dt>
</dl>
<p>How the grouping of Gofer de�nitions follows from their indentation is formally speci�ed by the o�side rule. The essence of the rule is as follows: consecutive de�- nitions that begin in the same column c are deemed to be part of the same group. To make parsing easier, it is further required that the remainder of the text of each de�nition (excluding white-space and comments, of course) in a group must occur in a column strictly greater than c. In terms of the o�side rule then, de�nitions a and d in the example program above are formally grouped together (and similarly for b and c) because they start in the same column as one another. 8.2 Modifying the type of parsers To implement the o�side rule, we will have to maintain some extra information during parsing. First of all, since column numbers play a crucial role in the o�side rule, parsers will need to know the column number of the �rst character in their input string. In fact, it turns out that parsers will also require the current line number. Thus our present type of combinator parsers, type Parser a = StateM [] String a is revised to the following type, in which the internal state of a parser now contains a (line,column) position in addition to a string: type Parser a = StateM [] Pstring a type Pstring = (Pos,String) type Pos = (Int,Int) In addition, parsers will need to know the starting position of the current de�nition being parsed | if the o�side rule is not in e�ect, this de�nition position can be set with a negative column number. Thus our type of parsers is revised once more, to take the current de�nition position as an extra argument: type Parser a = Pos -&gt; StateM [] Pstring a Another option would have been to maintain the de�nition position in the parser state, along with the current position and the string to be parsed. However, de�nition positions can be nested, and supplying the position as an extra argument to parsers | as opposed to within the parser state | is more natural from the point of view of implementing nesting of positions. Is the revised Parser type still a monad? Abstracting from the details, the body of the Parser type de�nition is of the form s -&gt; m a (in our case s is Pos, m is the monad StateM [] Pstring, and a is the parameter type a.) We recognise this as being similar to the type s -&gt; m (a,s) of parameterised state-transformers, the di�erence being that the type s of states no longer occurs in the type of the result: in other words, the state can be read, but not modi�ed. Thus we can think of s -&gt; m a as the type of parameterised state-readers. The monadic nature of this type is the topic of the next section. 8.3 The parameterised state-reader monad Consider the type constructor ReaderM, de�ned as follows: type ReaderM m s a = s -&gt; m a In a similar way to StateM m s, ReaderM m s can be made into a monad with a zero and a plus, by inheriting the monad operations from the base monad m: instance Monad m =&gt; Monad (ReaderM m s) where -- result&nbsp;:: a -&gt; ReaderM m s a result v = \s -&gt; result v -- bind&nbsp;:: ReaderM m s a -&gt; -- (a -&gt; ReaderM m s b) -&gt; ReaderM m s b srm `bind` f = \s -&gt; srm s `bind` \v -&gt; f v s instance Monad0Plus m =&gt; Monad0Plus (ReaderM m s) where -- zero&nbsp;:: ReaderM m s a zero = \s -&gt; zero -- (++)&nbsp;:: ReaderM m s a -&gt; -- ReaderM m s a -&gt; ReaderM m s a srm ++ srm' = \s -&gt; srm s ++ srm' s That is, result converts a value into a computation that returns this value without consulting the state; bind chains two computations together, with the same state being passed to both computations (contrast with the bind operation for StateM, in which the second computation receives the new state produced by the �rst computation); zero is the computation that fails; and �nally, (++) is a choice operation that passes the same state to both of the argument computations. To allow us to access and set the state, a couple of extra operations on the parameterised state-reader monad ReaderM m s are introduced. As for StateM, we encapsulate the extra operations in a class. The operation env returns the state as the result of the computation, while setenv replaces the current state for a given computation with a new state: class Monad m =&gt; ReaderMonad m s where env&nbsp;:: m s setenv&nbsp;:: s -&gt; m a -&gt; m a instance Monad m =&gt; ReaderMonad (ReaderM m s) s where -- env&nbsp;:: Monad m =&gt; ReaderM m s s env = \s -&gt; result s -- setenv&nbsp;:: Monad m =&gt; s -&gt; -- ReaderM m s a -&gt; ReaderM m s a setenv s srm = \_ -&gt; srm s The name env comes from the fact that one can think of the state supplied to a state-reader as being a kind of environment. Indeed, in the literature state-reader monads are sometimes called environment monads. 8.4 The new parser combinators Using the ReaderM type constructor, our revised type of parsers type Parser a = Pos -&gt; StateM [] Pstring a can now be expressed as follows: type Parser a = ReaderM (StateM [] Pstring) Pos a Now since [] forms a monad with a zero and a plus, so does StateM [] Pstring, and hence so does ReaderM (StateM [] Pstring) Pos. Thus Gofer automatically provides result, bind, zero, and (++) operations for parsers that can handle the o�side rule. Since the type of parsers is now de�ned in terms of ReaderM at the top level, the extra operations env and setenv are also provided for parsers. Moreover, the extra operation update (and the derived operations set and fetch) from the underlying state monad can be lifted to the new type of parsers|or more generally, to any parameterised state-reader monad | by ignoring the environment: instance StateMonad m a =&gt; StateMonad (ReaderM m s) a where -- update&nbsp;:: StateMonad m a =&gt; (a -&gt; a) -&gt; ReaderM m s a update f = \_ -&gt; update f Now that the internal state of parsers has been modi�ed (from String to Pstring), the parser item for consuming single characters from the input must also be modi �ed. The new de�nition for item is similar to the old, item&nbsp;:: Parser Char item = [x | (x:_) &lt;- update tail] except that the item parser now fails if the position of the character to be consumed is not onside with respect to current de�nition position: item&nbsp;:: Parser Char item = [x | (pos,x:_) &lt;- update newstate , defpos &lt;- env , onside pos defpos] A position is onside if its column number is strictly greater than the current de�- nition column. However, the �rst character of a new de�nition begins in the same column as the de�nition column, so this is handled as a special case: onside&nbsp;:: Pos -&gt; Pos -&gt; Bool onside (l,c) (dl,dc) = (c &gt; dc) || (l == dl) The remaining auxiliary function, newstate, consumes the �rst character from the input string, and updates the current position accordingly (for example, if a newline character was consumed, the current line number is incremented, and the current column number is set back to zero): newstate&nbsp;:: Pstring -&gt; Pstring newstate ((l,c),x:xs) = (newpos,xs) where newpos = case x of '\n' -&gt; (l+1,0) '\t' -&gt; (l,((c `div` 8)+1)*8) _ -&gt; (l,c+1) One aspect of the o�side rule still remains to be addressed: for the purposes of this rule, white-space and comments are not signi�cant, and should always be successfully consumed even if they contain characters that are not onside. This can be handled by temporarily setting the de�nition position to (0;􀀀1) within the junk parser for white-space and comments: junk&nbsp;:: Parser () junk = [() | _ &lt;- setenv (0,-1) (many (spaces +++ comment))] All that remains now is to de�ne a combinator that parses a sequence of de�nitions subject to the Gofer o�side rule: many1_offside&nbsp;:: Parser a -&gt; Parser [a] many1_offside p = [vs | (pos,_) &lt;- fetch , vs &lt;- setenv pos (many1 (off p))] That is, many1 offside p behaves just as many1 (off p), except that within this parser the de�nition position is set to the current position. (There is no need to skip white-space and comments before setting the position, since this will already have been e�ected by proper use of the lexical combinators token and parse.) The auxiliary combinator off takes care of setting the de�nition position locally for each new de�nition in the sequence, where a new de�nition begins if the column position equals the de�nition column position: off&nbsp;:: Parser a -&gt; Parser a off p = [v | (dl,dc) &lt;- env , ((l,c),_) &lt;- fetch , c == dc , v &lt;- setenv (l,dc) p] For completeness, we also de�ne a combinator many offside that has the same behaviour as the combinator many1 offside, except that it can also parse an empty sequence of de�nitions: many_offside&nbsp;:: Parser a -&gt; Parser [a] many_offside p = many1_offside p +++ [[]] To illustrate the use of the new combinators de�ned above, let us modify our parser for �-expressions (section 6.2) so that the \let" construct permits nonempty sequences of local de�nitions subject to the o�side rule. The datatype Expr of expressions is �rst modi�ed so that the Let constructor has type [(String,Expr)] -&gt; Expr instead of String -&gt; Expr -&gt; Expr: data Expr = ... | Let [(String,Expr)] Expr | ... The only part of the parser that needs to be modi�ed is the parser local for local de�nitions, which now accepts sequences: local = [Let ds e | _ &lt;- symbol "let" , ds &lt;- many1_offside defn , _ &lt;- symbol "in" , e &lt;- expr] defn = [(x,e) | x &lt;- identifier , _ &lt;- symbol "=" , e &lt;- expr] We conclude this section by noting that the use of the o�side rule when laying out sequences of Gofer de�nitions is not mandatory. As shown in our initial example, one also has the option to include explicit layout information in the form of parentheses \f" and \g" around the sequence, with de�nitions separated by semi-colons \;". We leave it as an exercise to the reader to use many offside to de�ne a combinator that implements this convention. In summary then, to permit combinator parsers to handle the Gofer o�side rule, we changed the type of parsers to include some positional information, modi�ed the item and junk combinators accordingly, and de�ned two new combinators: many1 offside and many offside. All other necessary rede�ning of combinators is done automatically by the Gofer type system. 9 Acknowledgements The �rst author was employed by the University of Utrecht during part of the writing of this article, for which funding is gratefully acknowledged. Special thanks are due to Luc Duponcheel for many improvements to the implementation of the combinator libraries in Gofer (particularly concerning the use of type classes and restricted type synonyms), and to Mark P. Jones for detailed comments on the �nal draft of this article. 10 Appendix: a parser for data de�nitions To illustrate the monadic parser combinators developed in this article in a real-life setting, we consider the problem of parsing a sequence of Gofer datatype de�nitions. An example of such a sequence is as follows: data List a = Nil | Cons a (List a) data Tree a b = Leaf a | Node (Tree a b, b, Tree a b) Within the parser, datatypes will be represented as follows: type Data = (String, -- type name [String], -- parameters [(String,[Type])]) -- constructors and arguments The representation Type for types will be treated shortly. A parser datadecls&nbsp;:: Parser [Data] for a sequence of datatypes can now be de�ned by datadecls = many_offside datadecl datadecl = [(x,xs,b) | _ &lt;- symbol "data" , x &lt;- constructor , xs &lt;- many variable , _ &lt;- symbol "=" , b &lt;- condecl `sepby1` symbol "|"] constructor = token [(x:xs) | x &lt;- upper , xs &lt;- many alphanum] variable = identifier ["data"] condecl = [(x,ts) | x &lt;- constructor , ts &lt;- many type2] There are a couple of points worth noting about this parser. Firstly, all lexical issues (white-space and comments, the o�side rule, and keywords) are handled by combinators. And secondly, since constructor is a parser for a complete token, the token combinator is applied within its de�nition. Within the parser, types will be represented as follows: data Type = Arrow Type Type -- function | Apply Type Type -- application | Var String -- variable | Con String -- constructor | Tuple [Type] -- tuple | List Type -- list A parser type0&nbsp;:: Parser Type for types can now be de�ned by type0 = type1 `chainr1` [Arrow | _ &lt;- symbol "-&gt;"] type1 = type2 `chainl1` [Apply] type2 = var +++ con +++ list +++ tuple var = [Var x | x &lt;- variable] con = [Con x | x &lt;- constructor] list = [List x | x &lt;- bracket (symbol "[") type0 (symbol "]")] tuple = [f ts | ts &lt;- bracket (symbol "(") (type0 `sepby` symbol ",") (symbol ")")] where f [t] = t f ts = Tuple ts Note how chainr1 and chainl1 are used to handle parsing of function-types and application. Note also that (as in Gofer) building a singleton tuple (t) of a type t is not possible, since (t) is treated as a parenthesised expression. References Aho, A., Sethi, R., &amp; Ullman, J. (1986). Compilers | principles, techniques and tools. Addison-Wesley. Burge, W.H. (1975). Recursive programming techniques. Addison-Wesley. Fokker, Jeroen. 1995 (May). Functional parsers. Lecture notes of the Baastad Spring school on functional programming. Gill, Andy, &amp; Marlow, Simon. 1995 (Jan.). Happy: the parser generator for Haskell. University of Glasgow. Hughes, John. (1989). Why functional programming matters. The computer journal, 32(2), 98{107. Hutton, Graham. (1992). Higher-order functions for parsing. Journal of functional programming, 2(3), 323{343. Jones, Mark P. (1994). Gofer 2.30a release notes. Unpublished manuscript. Jones, Mark P. (1995a). Functional programming beyond the Hindley/Milner type system. Proc. lecture notes of the Baastad spring school on functional programming. Jones, Mark P. (1995b). The Gofer distribution. Available from the University of Nottingham: <a rel="nofollow" class="external free" href="http://www.cs.nott.ac.uk/Department/Staff/mpj/">http://www.cs.nott.ac.uk/Department/Staff/mpj/</a>. Jones, Mark P. (1995c). A system of constructor classes: overloading and implicit higherorder polymorphism. Journal of functional programming, 5(1), 1{35. Jones, Simon Peyton, &amp; Launchbury, John. (1994). State in Haskell. University of Glasgow. Landin, Peter. (1966). The next 700 programming languages. Communications of the ACM, 9(3). Mogensen, Torben. (1993). Ratatosk: a parser generator and scanner generator for Gofer. University of Copenhagen (DIKU). Moggi, Eugenio. (1989). Computation lambda-calculus and monads. Proc. IEEE symposium on logic in computer science. A extended version of the paper is available as a technical report from the University of Edinburgh. Rojemo, Niklas. (1995). Garbage collection and memory e�ciency in lazy functional languages. Ph.D. thesis, Chalmers University of Technology. Spivey, Mike. (1990). A functional theory of exceptions. Science of computer programming, 14, 25{42. Wadler, Philip. (1985). How to replace failure by a list of successes. Proc. conference on functional programming and computer architecture. Springer{Verlag. Wadler, Philip. (1990). Comprehending monads. Proc. ACM conference on Lisp and functional programming. Wadler, Philip. (1992a). The essence of functional programming. Proc. principles of programming languages. Wadler, Philip. (1992b). Monads for functional programming. Broy, Manfred (ed), Proc. Marktoberdorf Summer school on program design calculi. Springer{Verlag.</p>


<!-- 
NewPP limit report
Parsed by mw1209
CPU time usage: 0.237 seconds
Real time usage: 0.280 seconds
Preprocessor visited node count: 255/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 14483/2097152 bytes
Template argument size: 6023/2097152 bytes
Highest expansion depth: 13/40
Expensive parser function count: 0/500
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   53.750      1 - -total
 54.92%   29.517      1 - Шаблон:К_удалению
 44.85%   24.106      1 - Шаблон:Информация_об_авторе
 28.47%   15.300      1 - Шаблон:Ambox
 15.31%    8.231      1 - Шаблон:Просроченные_подведения_итогов
 13.56%    7.287      1 - Шаблон:Nobr
  5.97%    3.210      1 - Шаблон:Администраторам
-->

<!-- Saved in parser cache with key ruwikibooks:pcache:idhash:2416-0!*!0!!ru!4!* and timestamp 20150127202147 and revision id 99634
 -->
<noscript>&lt;img src="//ru.wikibooks.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /&gt;</noscript></div>									<div class="printfooter">
						Источник — «<a dir="ltr" href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&oldid=99634">http://ru.wikibooks.org/w/index.php?title=Монадические_комбинаторы_парсеров&amp;oldid=99634</a>»					</div>
													<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9A%D0%B0%D0%BD%D0%B4%D0%B8%D0%B4%D0%B0%D1%82%D1%8B_%D0%BD%D0%B0_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5" title="Категория:Викиучебник:Кандидаты на удаление">Викиучебник:Кандидаты на удаление</a></li><li><a href="http://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" title="Категория:Функциональное программирование">Функциональное программирование</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Скрытая категория: <ul><li><a href="http://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9F%D1%80%D0%BE%D1%81%D1%80%D0%BE%D1%87%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D1%82%D0%BE%D0%B3%D0%BE%D0%B2_%D0%BF%D0%BE_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86" title="Категория:Викиучебник:Просроченные подведения итогов по удалению страниц">Викиучебник:Просроченные подведения итогов по удалению страниц</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Персональные инструменты</h3>
						<ul>
							<li id="pt-createaccount"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&returnto=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B+%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&type=signup" title="Мы предлагаем вам создать учётную запись и войти в систему, хотя это и не обязательно.">Создать учётную запись</a></li><li id="pt-login"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&returnto=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B+%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2" title="Здесь можно зарегистрироваться в системе, но это необязательно. [ctrl-option-o]" accesskey="o">Войти</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Пространства имён</h3>
						<ul>
															<li id="ca-nstab-main" class="selected"><span><a href="./Монадические комбинаторы парсеров — Викиучебник_files/Монадические комбинаторы парсеров — Викиучебник.html" title="Просмотр основной страницы [ctrl-option-c]" accesskey="c">Учебник</a></span></li>
															<li id="ca-talk" class="new"><span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit&redlink=1" title="Обсуждение страницы [ctrl-option-t]" accesskey="t">Обсуждение</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label" tabindex="0"><span>Варианты</span><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#" tabindex="-1"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Просмотры</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="./Монадические комбинаторы парсеров — Викиучебник_files/Монадические комбинаторы парсеров — Викиучебник.html">Читать</a></span></li>
															<li id="ca-edit"><span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=edit" title="Вы можете редактировать эту страницу. Перед тем, как записать свои изменения, воспользуйтесь, пожалуйста, кнопкой предварительного просмотра. [ctrl-option-e]" accesskey="e">Править</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=history" title="Журнал изменений страницы [ctrl-option-h]" accesskey="h">История</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label" tabindex="0"><span>Ещё</span><a href="http://ru.wikibooks.org/wiki/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2#" tabindex="-1"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Поиск</label>
						</h3>

						<form action="http://ru.wikibooks.org/w/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Поиск" title="Искать в Викиучебнике [ctrl-option-f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off"><input type="hidden" value="Служебная:Поиск" name="title"><input type="submit" name="go" value="Перейти" title="Перейти к странице, имеющей в точности такое название" id="searchButton" class="searchButton">								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="http://ru.wikibooks.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Навигация</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage"><a href="http://ru.wikibooks.org/wiki/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [ctrl-option-z]" accesskey="z">Заглавная страница</a></li>
													<li id="n-catalog"><a href="http://ru.wikibooks.org/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%92%D1%81%D1%91">Каталог</a></li>
													<li id="n-randompage"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Посмотреть случайно выбранную страницу [ctrl-option-x]" accesskey="x">Случайная статья</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-participation" aria-labelledby="p-participation-label">
			<h3 id="p-participation-label">Участие</h3>

			<div class="body">
									<ul>
													<li id="n-help"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0" title="Место, где можно получить справку">Справка</a></li>
													<li id="n-forum"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9E%D0%B1%D1%89%D0%B8%D0%B9_%D1%84%D0%BE%D1%80%D1%83%D0%BC">Форум</a></li>
													<li id="n-recentchanges"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [ctrl-option-r]" accesskey="r">Свежие правки</a></li>
													<li id="n-newpages"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9D%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B">Новые страницы</a></li>
													<li id="n-sitesupport"><a href="http://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_campaign=C13_ru.wikibooks.org&uselang=ru" title="Поддержите нас">Пожертвования</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Инструменты</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2" title="Список всех страниц, ссылающихся на данную [ctrl-option-j]" accesskey="j">Ссылки сюда</a></li>
													<li id="t-recentchangeslinked"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2" title="Последние изменения в страницах, на которые ссылается эта страница [ctrl-option-k]" accesskey="k">Связанные правки</a></li>
													<li id="t-specialpages"><a href="http://ru.wikibooks.org/wiki/%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [ctrl-option-q]" accesskey="q">Спецстраницы</a></li>
													<li id="t-permalink"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&oldid=99634" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
													<li id="t-info"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&action=info" title="Подробнее об этой странице">Сведения о&nbsp;странице</a></li>
						<li id="t-cite"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A6%D0%B8%D1%82%D0%B0%D1%82%D0%B0&page=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&id=99634" title="Информация о том, как цитировать эту страницу">Цитировать страницу</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-coll-print_export" aria-labelledby="p-coll-print_export-label">
			<h3 id="p-coll-print_export-label">Печать/экспорт</h3>

			<div class="body">
									<ul>
													<li id="coll-create_a_book"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_%D0%BA%D0%BD%D0%B8%D0%B3&bookcmd=book_creator&referer=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B+%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2">Создать книгу</a></li>
													<li id="coll-download-as-rdf2latex"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F_%D0%BA%D0%BD%D0%B8%D0%B3&bookcmd=render_article&arttitle=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B+%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&oldid=99634&writer=rdf2latex">Скачать как PDF</a></li>
													<li id="t-print"><a href="http://ru.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&printable=yes" title="Версия этой страницы для печати [ctrl-option-p]" accesskey="p">Версия для печати</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-lang" aria-labelledby="p-lang-label"><span class="uls-settings-trigger" title="Установки языка" tabindex="0" role="button" aria-haspopup="true"></span>
			<h3 id="p-lang-label">Языки</h3>

			<div class="body">
									<ul>
													
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 12:13, 22 ноября 2014.</li>
											<li id="footer-info-copyright">Текст доступен по <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.ru">лицензии Creative Commons Attribution-ShareAlike</a>, в отдельных случаях могут действовать дополнительные условия. Подробнее см. <a href="https://wikimediafoundation.org/wiki/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Условия использования</a>.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="Викиучебник:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" title="Викиучебник:Введение">Введение</a></li>
											<li id="footer-places-disclaimer"><a href="http://ru.wikibooks.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%83%D1%87%D0%B5%D0%B1%D0%BD%D0%B8%D0%BA:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="Викиучебник:Отказ от ответственности">Отказ от ответственности</a></li>
											<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Разработчики</a></li>
											<li id="footer-places-mobileview"><a href="http://ru.m.wikibooks.org/w/index.php?title=%D0%9C%D0%BE%D0%BD%D0%B0%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%BF%D0%B0%D1%80%D1%81%D0%B5%D1%80%D0%BE%D0%B2&mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Мобильная версия</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://wikimediafoundation.org/"><img src="./Монадические комбинаторы парсеров — Викиучебник_files/wikimedia-button.png" srcset="//bits.wikimedia.org/images/wikimedia-button-1.5x.png 1.5x, //bits.wikimedia.org/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="http://www.mediawiki.org/"><img src="./Монадические комбинаторы парсеров — Викиучебник_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="//bits.wikimedia.org/static-1.25wmf16/resources/assets/poweredby_mediawiki_132x47.png 1.5x, //bits.wikimedia.org/static-1.25wmf16/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"ext.globalCssJs.site":"ready","ext.globalCssJs.user":"ready","site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","mmv.bootstrap.autostart","ext.eventLogging.subscriber","ext.wikimediaEvents.statsd","ext.navigationTiming","schema.UniversalLanguageSelector","ext.uls.eventlogger","ext.uls.interlanguage"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"//bits.wikimedia.org/ru.wikibooks.org/load.php?debug=false\u0026amp;lang=ru\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script><script src="./Монадические комбинаторы парсеров — Викиучебник_files/load(3).php"></script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":85,"wgHostname":"mw1252"});
}</script>
	

<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div><div style="display: none;"><p><a href="http://ru.wikibooks.org/w/index.php?title=MediaWiki:ImageAnnotatorTexts&action=edit&redlink=1" class="new" title="MediaWiki:ImageAnnotatorTexts (страница не существует)">MediaWiki:ImageAnnotatorTexts</a></p>


<!-- 
NewPP limit report
Parsed by mw1145
CPU time usage: 0.006 seconds
Real time usage: 0.007 seconds
Preprocessor visited node count: 2/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 34/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/500
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    3.840      1 - MediaWiki:ImageAnnotatorTexts
100.00%    3.840      1 - -total
-->
</div></body></html>