<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kostya&#39;s Blog</title>
    <link>https://xni.github.io/</link>
    <description>Recent content on Kostya&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Jun 2020 13:30:00 +0100</lastBuildDate>
    
        <atom:link href="https://xni.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Competition: C&#43;&#43; delayed call</title>
        <link>https://xni.github.io/tech/i-like-to-move-it/</link>
        <pubDate>Fri, 05 Jun 2020 13:30:00 +0100</pubDate>
        
        <guid>https://xni.github.io/tech/i-like-to-move-it/</guid>
        <description>Kostya&#39;s Blog https://xni.github.io/tech/i-like-to-move-it/ -&lt;p&gt;Amount of positive feedback foforious post motivated me to
go one step further to put a fat dot on this topic.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s have some fun! I am launching a competition for the fastest code
for making a delayed function call.&lt;/p&gt;
&lt;p&gt;The rules are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You are sending me your solution before 14th of June 2020 to
&lt;a href=&#34;mailto:smartlemon@protonmail.com&#34;&gt;smartlemon@protonmail.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;m running some tests for correctness. You don&amp;rsquo;t know my tests.
I will reply back to you, if the tests are failing, describing the error.
Each submission which fails test adds you 1 yellow card.&lt;/li&gt;
&lt;li&gt;Amongs all of the correct submissions (passing every test), sent to me before 2020-06-14 23:59:59 UTC
I will select the fastest one using a pretty trivial set of cases.
I will select the fastest by creating a benchmark on quick-bench. If there are multiple
fastest solutions, one with the least amount of yellow cards will win.&lt;/li&gt;
&lt;li&gt;The winner will receive my congratulations and respect from other participants.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now about the task. You need to use C++17. You need to write a templated C++ class, &lt;code&gt;MaybeDelayedCall&lt;/code&gt;.
Constructor accepts at least 2 arguments, the argument &lt;code&gt;arg&lt;/code&gt; to pass to the function &lt;code&gt;F&lt;/code&gt;,
and a boolean param &lt;code&gt;now&lt;/code&gt;. Function &lt;code&gt;F&lt;/code&gt;, which needs to be called can be passed
as an argument as well, or using &lt;code&gt;auto&lt;/code&gt; template parameter. If you are using &lt;code&gt;auto&lt;/code&gt;
template parameter, you are allowed to have one failed submission without a yellow card.
If you are using C++17 template type auto deduction for classes, you are allowed to have
one failed submission without a yellow card.
If &lt;code&gt;now&lt;/code&gt; param is &lt;code&gt;true&lt;/code&gt;, function &lt;code&gt;F&lt;/code&gt; should be called with &lt;code&gt;arg&lt;/code&gt; immediately.
If &lt;code&gt;now&lt;/code&gt; param is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;MaybeDelayedCall&lt;/code&gt; should store the argument (in other words,
if &lt;code&gt;arg&lt;/code&gt; was passed as a reference, you are not allowed to save that reference, because
our delayed call can not guarantee lifetime expectations for the agrument), and call function &lt;code&gt;F&lt;/code&gt;
only when the method &lt;code&gt;OnTime()&lt;/code&gt; of &lt;code&gt;MaybeDelayedCall&lt;/code&gt; is invoked.
It is guaranteed that in every test, where I&amp;rsquo;m going to do &lt;code&gt;MaybeDelayedCall&amp;lt;...&amp;gt; x(arg, now)&lt;/code&gt;,
it is correct to write &lt;code&gt;F(arg)&lt;/code&gt;, in other words, &lt;code&gt;MaybeDelayedCall&lt;/code&gt; should not deal with
a problem that &lt;code&gt;arg&lt;/code&gt; is not compatible with &lt;code&gt;F&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also important note: the performance tests will have a following structure&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestForKostya&lt;/span&gt;()
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        MaybeDelayedCall&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x(arg, now);
        x.OnTime();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;so you don&amp;rsquo;t have to deal with delayed calls, we are just measuring the effeciency
of a storing/passing. Also important note - object &lt;code&gt;x&lt;/code&gt; is allocated on the stack.&lt;/p&gt;
&lt;p&gt;If you have any questions, don&amp;rsquo;t hesitate to reach me by email &lt;a href=&#34;mailto:smartlemon@protonmail.com&#34;&gt;smartlemon@protonmail.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Good luck!&lt;/p&gt;
- https://xni.github.io/tech/i-like-to-move-it/ - </description>
        </item>
    
    
    
        <item>
        <title>C&#43;&#43; Move Semantics: my &#39;Aha!&#39; moment</title>
        <link>https://xni.github.io/tech/move-semantics-aha-moment/</link>
        <pubDate>Sun, 31 May 2020 07:50:00 +0100</pubDate>
        
        <guid>https://xni.github.io/tech/move-semantics-aha-moment/</guid>
        <description>Kostya&#39;s Blog https://xni.github.io/tech/move-semantics-aha-moment/ -&lt;p&gt;As a C++ developer I learned that rvalue referece becomes lvalue right after passing it
as an argument. And I just accepted it, learned it and tried to never think about it,
because for me it didn&amp;rsquo;t make any sense. Until recently. Now I understood the motives why
it was done and I&amp;rsquo;m going to share this with you!&lt;/p&gt;
&lt;p&gt;OK, I&amp;rsquo;m going to shut up and show you the code!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(s);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will produce &lt;code&gt;S::S(const S &amp;amp;) S.x = 1&lt;/code&gt; output. And just as a reminder, if you have received
rvalue as an argument, and want to pass it forward, you need you use &lt;code&gt;std::move&lt;/code&gt; (or &lt;code&gt;std::forward&lt;/code&gt; if you
are &lt;a href=&#34;https://habr.com/ru/post/242639/&#34;&gt;using&lt;/a&gt; special type deduction rules). And that was always confusing
to me.&lt;/p&gt;
&lt;p&gt;So, in most of the cases my code looked like that (added &lt;code&gt;std::move(s)&lt;/code&gt; on the line 22)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output now is: &lt;code&gt;S::S(S &amp;amp;&amp;amp;) S.x = 1&lt;/code&gt;, i.e. by adding &lt;code&gt;std::move&lt;/code&gt; we passed rvalue as rvalue. What&amp;rsquo;s the hell!
And I was thinking: &amp;ldquo;OK, I have to do it like that, because someone created that stupid rule&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;This was my mindset until recently, where I had to write some library function to schedule
delayed function calls with as few copies as possible. I will not give sources of that scheduler,
but there were some interesting things I faced during working on it. I will reflect them in my example.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say that now I need to call &lt;code&gt;SubProcess&lt;/code&gt; from &lt;code&gt;Process&lt;/code&gt; twice. Let&amp;rsquo;s see what will happen
in the original (without an extra &lt;code&gt;std::move()&lt;/code&gt;) version:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(s);
    SubProcess(s);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S::S(const S &amp;amp;)
 S.x = 1
S::S(const S &amp;amp;)
 S.x = 1 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, nothing special, right. But now, let&amp;rsquo;s imagine that our rvalue were staying as rvalues!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(&lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;(s));
    SubProcess(&lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the output is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S::S(S &amp;amp;&amp;amp;)
 S.x = 1
S::S(S &amp;amp;&amp;amp;)
 S.x = 0 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That makes perfect sense, because our move constuctor destroyed the &lt;code&gt;x&lt;/code&gt; value of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I think that was the motivation behind the rule that rvalue reference is passed as an lvalue
without std::move. Generally it is some protection, by placing &lt;code&gt;std::move()&lt;/code&gt;
around the argument, you admitting that the value is not required later.&lt;/p&gt;
&lt;p&gt;Things can become even more interesting in case of templates!
Let&amp;rsquo;s start with current default C++ behaviour:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Process(X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(s);
    SubProcess(s);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
    S s;
    Process(s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S::S(const S &amp;amp;)
 S.x = 1
S::S(const S &amp;amp;)
 S.x = 1
S::S(const S &amp;amp;)
 S.x = 1
S::S(const S &amp;amp;)
 S.x = 1 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And with my &amp;ldquo;improved&amp;rdquo; C++:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Process(X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;forward&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(s));
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;forward&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
    S s;
    Process(s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Believe it or not, but the same template function produced two different results!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S::S(S &amp;amp;&amp;amp;)
 S.x = 1
S::S(S &amp;amp;&amp;amp;)
 S.x = 0
S::S(const S &amp;amp;)
 S.x = 1
S::S(const S &amp;amp;)
 S.x = 1 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be honest, this was enough to convince be that &lt;code&gt;std::move&lt;/code&gt; and &lt;code&gt;std::forward&lt;/code&gt; are
really a good protection mechanism. Imagine the opposite: if rvalue remains rvalue,
and you need to do &lt;code&gt;std::dontmove(v)&lt;/code&gt; every time when you want to pass &lt;code&gt;v&lt;/code&gt;, but you
need its result later as well!&lt;/p&gt;
&lt;p&gt;Just a couple of side notes, which appeared when I was working on this article.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passing the element as an rvalue reference does not call a copy constructor&lt;/strong&gt;, it is just like
passing the element by reference, where the reference has a semantics &amp;ldquo;you know what, caller
doesn&amp;rsquo;t need my value&amp;rdquo;. It doesn&amp;rsquo;t mean you have to destroy it. You just can, if you want. See:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Result is &lt;code&gt;1 1 1&lt;/code&gt;, so we have just passed the element as rvalue reference, didn&amp;rsquo;t call a copy
constructor, the original object remained the same. It will only be broken if it something will
call a move constructor inside &lt;code&gt;SubProcess&lt;/code&gt; function for exmample:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    S cpy(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 S::S(S &amp;amp;&amp;amp;)
 S.x = 1
0 S::S(S &amp;amp;&amp;amp;)
 S.x = 0
0 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Passing by rvalue reference does not steal the value, it just allows the value to be stolen!
But actually you can even &amp;ldquo;steal&amp;rdquo; a lvalue!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    S cpy(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
    SubProcess(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s));
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    S s;
    Process(s);
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;S.x=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S::S(S &amp;amp;&amp;amp;)
 S.x = 1
S::S(S &amp;amp;&amp;amp;)
 S.x = 0
S.x=0  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, rvalue reference is only a feature for overload selection and nothing more than that.&lt;/p&gt;
&lt;p&gt;Also, constructing rvalue reference from rvalue reference and storing it somewhere - also acts as lvalue.
In other worlds, stored rvalue reference is actually an lvalue:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt; {
    S() &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; x(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}
    S(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    S(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; __PRETTY_FUNCTION__ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; S.x = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
        s.x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubProcess&lt;/span&gt;(S s) {
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;(S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s) {
    S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(s);
    SubProcess(s1);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    Process(S());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output: &lt;code&gt;S::S(const S &amp;amp;) S.x = 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;: there is no such a thing as &amp;ldquo;stored rvalue reference&amp;rdquo;, this concept
only needed to select the right overload. And this is may look weird at a first sight,
but without it, amount of bugs in our code will increase significantly, because in that
case the Committee chosen safer and slower behaviour as a default.&lt;/p&gt;
&lt;p&gt;If you learned something new from this article, why not to support the author by buying
them a cuppa?&lt;/p&gt;
- https://xni.github.io/tech/move-semantics-aha-moment/ - </description>
        </item>
    
    
    
        <item>
        <title>GDB basics</title>
        <link>https://xni.github.io/tech/gdb-basics/</link>
        <pubDate>Sat, 18 Apr 2020 14:30:00 +0100</pubDate>
        
        <guid>https://xni.github.io/tech/gdb-basics/</guid>
        <description>Kostya&#39;s Blog https://xni.github.io/tech/gdb-basics/ -&lt;p&gt;I need to confess: I have&amp;rsquo;t use GDB any how seriously before. May be just some basics
like start an app, wait for it to crash, and then do &lt;code&gt;bt&lt;/code&gt; to figure out that
&lt;code&gt;this&lt;/code&gt; was equal to 0. So this article is going to be a very entry level, gentle
intro in GDB for C++.&lt;/p&gt;
&lt;p&gt;In my current company we are using GDB a lot. The easiest way to debug things
is now a debugger! In this short article I&amp;rsquo;m going to show how I am using gdb
right now. It if mostly dedicated to breakpoints, and not a reference anyhow.&lt;/p&gt;
&lt;p&gt;We will write a simple application and then we will use gdb to explore a couple
of bugs.&lt;/p&gt;
&lt;p&gt;This will be an application source:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;experimental/string_view&amp;gt;

template &amp;lt;typename A, typename B&amp;gt;
class RequestProcessor {
public:
  std::experimental::string_view extractField(std::experimental::string_view field, std::experimental::string_view req) {
      const auto pEq = req.find(field) + field.size() + 1;
      const auto pSp = req.find(&#39; &#39;, pEq);
      return req.substr(pEq, pSp - pEq);
  }

  bool isAllowed(std::experimental::string_view req) {
      return extractField(&amp;quot;Name=&amp;quot;, req) == &amp;quot;Kate&amp;quot;;
  }

  void processRequest(std::experimental::string_view req) {
    if (!isAllowed(req))
        return;
    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {
        std::cout &amp;lt;&amp;lt; &amp;quot;You are here\n&amp;quot;;
    }
  }
};


int main() {
    RequestProcessor&amp;lt;int, std::string&amp;gt; p;
    p.processRequest(&amp;quot;Name=John Data=1 &amp;quot;);
    p.processRequest(&amp;quot;Name=John Data=2 &amp;quot;);
    p.processRequest(&amp;quot;Name=John Data=3 &amp;quot;);
    p.processRequest(&amp;quot;Name=John Data=4 &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So we would like to see &amp;ldquo;You are here&amp;rdquo; in the terminal.
But it is not what&amp;rsquo;s happening:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@b004b64b9456:/# g++ -std=c++17 -g main.cpp 
root@b004b64b9456:/# ./a.out 
root@b004b64b9456:/# 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What I will try to do first is to create a setup where it is
easy to achieve the state of my application where the possible
bug is. In this current situation I would like to create a breakpoint
before executing the line &lt;code&gt;if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;)&lt;/code&gt;,
because we probably have a bug in the &lt;code&gt;extractField&lt;/code&gt; method.
Also, to make things easier, we would like to skip 3 other crossings
of this breakpoint and stop only of the fouth. Let&amp;rsquo;s do it!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@b004b64b9456:/# gdb a.out 
GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from a.out...

(gdb) break main.cpp:22
Breakpoint 1 at 0x18f8: file main.cpp, line 22.

(gdb) ignore 1 3
Will ignore next 3 crossings of breakpoint 1.

(gdb) r
Starting program: /a.out 
warning: Error disabling address space randomization: Operation not permitted
[Inferior 1 (process 1161) exited normally]
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh, wow, as you can see, something went wrong, our program exited without
stopping on a breakpoint. Looking more carefully into the code, you can see,
that probably the issue is with an &lt;code&gt;isAllowed&lt;/code&gt; method. Let&amp;rsquo;s say that we
know for sure that in production this method is not an issue and we don&amp;rsquo;t
want to fight with it in our development environment. We just want it to
return true. Easy! We are continuing our debugging session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) rbreak isAllowed
Breakpoint 2 at 0x55e93008e994: file main.cpp, line 15.
bool RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed(std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;);

(gdb) commands 2
Type commands for breakpoint(s) 2, one per line.
End with a line saying just &amp;quot;end&amp;quot;.
&amp;gt;return true
&amp;gt;continue
&amp;gt;end

(gdb) r
Starting program: /a.out 
warning: Error disabling address space randomization: Operation not permitted

Breakpoint 2, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed (
    this=0x7f5760c566bf &amp;lt;std::num_get&amp;lt;wchar_t, std::istreambuf_iterator&amp;lt;wchar_t, std::char_traits&amp;lt;wchar_t&amp;gt; &amp;gt; &amp;gt; const&amp;amp; std::use_facet&amp;lt;std::num_get&amp;lt;wchar_t, std::istreambuf_iterator&amp;lt;wchar_t, std::char_traits&amp;lt;wchar_t&amp;gt; &amp;gt; &amp;gt; &amp;gt;(std::locale const&amp;amp;)+63&amp;gt;, 
    req=&amp;quot;\220I\316`W\177\000\000\000\000\000\000\000\000\000\000\270I\316`W\177\000\000\006&amp;quot;, &#39;\000&#39; &amp;lt;repeats 15 times&amp;gt;, &amp;quot;\002\020&amp;quot;, &#39;\000&#39; &amp;lt;repeats 158 times&amp;gt;...) at main.cpp:15
15	  bool isAllowed(std::experimental::string_view req) {

Breakpoint 2, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed (this=0x7fffd673f570, req=&amp;quot;&amp;quot;)
    at main.cpp:15
15	  bool isAllowed(std::experimental::string_view req) {

Breakpoint 2, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed (this=0x7fffd673f570, req=&amp;quot;&amp;quot;)
    at main.cpp:15
15	  bool isAllowed(std::experimental::string_view req) {

Breakpoint 2, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed (this=0x7fffd673f570, req=&amp;quot;&amp;quot;)
    at main.cpp:15
15	  bool isAllowed(std::experimental::string_view req) {

Breakpoint 1, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest (this=0x7fffd673f62f, 
    req=&amp;quot;Name=John Data=4 &amp;quot;) at main.cpp:22
22	    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It works!&lt;/p&gt;
&lt;p&gt;Here I&amp;rsquo;ve used &lt;code&gt;rbreak&lt;/code&gt; command. It creates a breakpoint by a part of a function name (&lt;code&gt;isAllowed&lt;/code&gt; in our case).
You can also use &lt;code&gt;break&lt;/code&gt; and specify the full name, but the full name, as you can see, is not
really straighforward, because templated arguments and a class name are also a part of a full name for gdb.&lt;/p&gt;
&lt;p&gt;Now we have a setup, which allows us to stop near the expected bug. And I do want to save this setup
in order to return to the debugging session later, or to be able to easily restart the application.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) save breakpoints my_debugging  
Saved to file &#39;my_debugging&#39;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we quit the debugger and re-enter it again we can easily restore this setup:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@b004b64b9456:/# gdb a.out 
GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from a.out...

(gdb) source my_debugging 
Breakpoint 1 at 0x18f8: file main.cpp, line 22.
Breakpoint 2 at 0x1994: file main.cpp, line 15.

(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000000018f8 in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest(std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;) at main.cpp:22
2       breakpoint     keep y   0x0000000000001994 in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed(std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;) at main.cpp:15
        return true
        continue

(gdb) r
Starting program: /a.out 
warning: Error disabling address space randomization: Operation not permitted

Breakpoint 2, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::isAllowed (
    this=0x7f47c00756bf &amp;lt;std::num_get&amp;lt;wchar_t, std::istreambuf_iterator&amp;lt;wchar_t, std::char_traits&amp;lt;wchar_t&amp;gt; &amp;gt; &amp;gt; const&amp;amp; std::use_facet&amp;lt;std::num_get&amp;lt;wchar_t, std::istreambuf_iterator&amp;lt;wchar_t, std::char_traits&amp;lt;wchar_t&amp;gt; &amp;gt; &amp;gt; &amp;gt;(std::locale const&amp;amp;)+63&amp;gt;, req=&amp;quot;&amp;quot;) at main.cpp:15
15	  bool isAllowed(std::experimental::string_view req) {

Breakpoint 1, RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest (this=0x7ffe6da9202f, 
    req=&amp;quot;Name=John Data=1 &amp;quot;) at main.cpp:22
22	    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, &lt;code&gt;source&lt;/code&gt; command restored all of the breakpoints, with their settings:
&lt;code&gt;info breakpoints&lt;/code&gt; shows it.&lt;/p&gt;
&lt;p&gt;And now let&amp;rsquo;s jump into the &lt;code&gt;extractField&lt;/code&gt; method. In order to do so, we are calling &lt;code&gt;step&lt;/code&gt;,
which means &amp;ldquo;execute until the control flow will change to another line&amp;rdquo; Another useful
command is &lt;code&gt;next&lt;/code&gt;, &amp;ldquo;execute until the control flow will reach the NEXT line&amp;rdquo;. As you
can see, in the presense of nested instructions, if you want to follow them, you need a &lt;code&gt;step&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) step
std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::basic_string_view (this=0x7f47c0109ee0 &amp;lt;std::wcerr&amp;gt;, 
    __str=0x7f47c0109ee0 &amp;lt;std::wcerr&amp;gt; &amp;quot;0D\020\300G\177&amp;quot;) at /usr/include/c++/9/experimental/string_view:108
108	      constexpr basic_string_view(const _CharT* __str)

(gdb) finish
Run till exit from #0  std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::basic_string_view (
    this=0x7f47c0109ee0 &amp;lt;std::wcerr&amp;gt;, __str=0x7f47c0109ee0 &amp;lt;std::wcerr&amp;gt; &amp;quot;0D\020\300G\177&amp;quot;) at /usr/include/c++/9/experimental/string_view:108
0x000055e3b205a90b in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest (
    this=0x7ffe6da9202f, req=&amp;quot;Name=John Data=1 &amp;quot;) at main.cpp:22
22	    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {

(gdb) step
std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::basic_string_view (this=0x7ffe6da91fe0, __str=0x55e3b205b050 &amp;quot;4&amp;quot;)
    at /usr/include/c++/9/experimental/string_view:108
108	      constexpr basic_string_view(const _CharT* __str)

(gdb) finish
Run till exit from #0  std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::basic_string_view (this=0x7ffe6da91fe0, 
    __str=0x55e3b205b050 &amp;quot;4&amp;quot;) at /usr/include/c++/9/experimental/string_view:108
0x000055e3b205a91e in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest (
    this=0x7ffe6da9202f, req=&amp;quot;Name=John Data=1 &amp;quot;) at main.cpp:22
22	    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {

(gdb) step
RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::extractField (this=0x55e3b205b052, field=&amp;quot;&amp;quot;, req=&amp;quot;&amp;quot;)
    at main.cpp:9
9	  std::experimental::string_view extractField(std::experimental::string_view field, std::experimental::string_view req) {
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, before we were able to reach &lt;code&gt;extractField&lt;/code&gt;, we had visited two constructors for &lt;code&gt;string_view&lt;/code&gt;, that makes perfect sense.
When during the &lt;code&gt;step&lt;/code&gt; invocation you are jumping into the function you are not interested in, just type &lt;code&gt;finish&lt;/code&gt;,
to let this function to finish, and return to the point, where you can type &lt;code&gt;step&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s execute two subsequent lines and check what&amp;rsquo;s going on:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) n
10	      const auto pEq = req.find(field) + field.size() + 1;
(gdb) n
11	      const auto pSp = req.find(&#39; &#39;, pEq);
(gdb) n
12	      return req.substr(pEq, pSp - pEq);
(gdb) p field
$1 = &amp;quot;Data=&amp;quot;
(gdb) p req
$2 = &amp;quot;Name=John Data=4 &amp;quot;
(gdb) p pEq
$3 = 16
(gdb) p pSp
$4 = 16
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Doesn&amp;rsquo;t look right. &lt;code&gt;pEq&lt;/code&gt; was expected to be the index of the first character after &lt;code&gt;Data=&lt;/code&gt; in &lt;code&gt;req&lt;/code&gt;.
Which is 15. If we restart session and jump into the &lt;code&gt;find&lt;/code&gt;, and then use &lt;code&gt;finish&lt;/code&gt; we can see that
&lt;code&gt;find&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) n
10	      const auto pEq = req.find(field) + field.size() + 1;
(gdb) s
std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::find (this=0xa, 
    __str=&amp;lt;error: Cannot access memory at address 0x360016734595d100&amp;gt;, __pos=1) at /usr/include/c++/9/experimental/string_view:323
323	      find(basic_string_view __str, size_type __pos = 0) const noexcept
(gdb) fin
Run till exit from #0  std::experimental::fundamentals_v1::basic_string_view&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt;::find (this=0xa, 
    __str=&amp;lt;error: Cannot access memory at address 0x360016734595d100&amp;gt;, __pos=1) at /usr/include/c++/9/experimental/string_view:323
0x0000561939cc9a96 in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::extractField (
    this=0x7ffc4d20ff8f, field=&amp;quot;Data=&amp;quot;, req=&amp;quot;Name=John Data=4 &amp;quot;) at main.cpp:10
10	      const auto pEq = req.find(field) + field.size() + 1;
Value returned is $1 = 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The issue is in &lt;code&gt;+ 1&lt;/code&gt;. Let&amp;rsquo;s modify the value of &lt;code&gt;pEq&lt;/code&gt; on the fly, before entering
the computation of &lt;code&gt;pSp&lt;/code&gt;. In order to do it, we can use &lt;code&gt;set&lt;/code&gt; command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) p pEq
$2 = 16
(gdb) set pEq = 15
(gdb) p pEq
$3 = 15
(gdb) fin
Run till exit from #0  RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::extractField (
    this=0x7ffc4d20ff8f, field=&amp;quot;Data=&amp;quot;, req=&amp;quot;Name=John Data=4 &amp;quot;) at main.cpp:12
0x0000561939cc993d in RequestProcessor&amp;lt;int, std::__cxx11::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;::processRequest (
    this=0x7ffc4d20ff8f, req=&amp;quot;Name=John Data=4 &amp;quot;) at main.cpp:22
22	    if (extractField(&amp;quot;Data=&amp;quot;, req) == &amp;quot;4&amp;quot;) {
Value returned is $4 = &amp;quot;4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can see that the value returned from &lt;code&gt;extractField&lt;/code&gt; was correct, we can continue
the execution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) c
Continuing.
You are here
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Yay! We saw our log line. Without recompiling the code and any extra log lines. This is very nice,
when you compilation takes a while.&lt;/p&gt;
&lt;p&gt;I have remove the section about the conditional breakpoints, but in general, it is another powerful
addition to the &lt;code&gt;ignore&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;things-to-remember&#34;&gt;Things to remember&lt;/h2&gt;
&lt;p&gt;If you are a freak like me, you should have a flash cards for every book, blog post and podcast.
To make things easier to you I am summarizing the content of this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create a breakpoint by file name and line&lt;/strong&gt;? &lt;code&gt;break filename:line&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Create a breakpoint by exact function name&lt;/strong&gt;? &lt;code&gt;break long::function&amp;lt;name, with&amp;gt;::templates(and, parameters)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Create a breakpoint by a partial function name&lt;/strong&gt;? &lt;code&gt;rbreak partial_function_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ignore the next X crossing of breakpoint Y&lt;/strong&gt;? &lt;code&gt;ignore Y X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execute until the next line&lt;/strong&gt;? &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execute until the line is changed&lt;/strong&gt;? &lt;code&gt;step&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execute until the end of the function&lt;/strong&gt;? &lt;code&gt;finish&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Return some other value from the function without executing it&lt;/strong&gt;? &lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Do something when you hit a breakpoint Y&lt;/strong&gt;? &lt;code&gt;commands Y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conditional breakpoint&lt;/strong&gt;? &lt;code&gt;condition X &amp;lt;expression&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Print the value of a variable&lt;/strong&gt;? &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update the value of a variable&lt;/strong&gt;? &lt;code&gt;set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Save all breakpoints&lt;/strong&gt;? &lt;code&gt;save breakpoints &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Load breakpoints&lt;/strong&gt;? &lt;code&gt;source &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://xni.github.io/tech/gdb-basics/ - </description>
        </item>
    
    
    
        <item>
        <title>Reading through HEX</title>
        <link>https://xni.github.io/tech/hex-reading-interesting-facts/</link>
        <pubDate>Thu, 09 Apr 2020 21:14:00 +0100</pubDate>
        
        <guid>https://xni.github.io/tech/hex-reading-interesting-facts/</guid>
        <description>Kostya&#39;s Blog https://xni.github.io/tech/hex-reading-interesting-facts/ -&lt;p&gt;Right now I am improving our exchange connectivity libraries.
And one of the regular activities is anaylzing tcpdumps to validate what was sent over the wire.&lt;/p&gt;
&lt;p&gt;Doing this for nearly for the whole week I found couple of tricks.&lt;/p&gt;
&lt;h2 id=&#34;jumping-to-the-end-of-frame&#34;&gt;Jumping to the end of frame&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s say you have some frame-oriented protocol, like websocket
or EUREX ETI. Usually, message in those protocols start from the
&lt;code&gt;message_size&lt;/code&gt; field, then the message body follows, then the next
message and so on. So, if you want to jump from message N to the
message N+1 you need to skip message-size bytes.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say this is our tcpdump:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;48 00 00 00 01 02 03 04  ab cd ef f0 fe dc ba 98
00 00 11 12 45 9c 2a 23  62 22 b0 c1 38 52 55 6a
bb 52 21 01 34 a5 50 32  ba 51 b6 81 84 42 24 bb
13 ac 52 52 62 12 00 00  11 35 73 ba 51 62 72 31
58 25 40 00 30 00 00 11  31 00 62 65 bc bc 62 11
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code&gt;48 00 ...&lt;/code&gt; is the message size. Where does the second message starts from?
Before figuring out the first hack I was doing the following: 48 hex = 72 dec.
Ok, let&amp;rsquo;s count 72 characters&amp;hellip; so the next message is &lt;code&gt;31 00 ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;What I figured out eventually is that hexdump renders 16 bytes per line, so
48 in hex actually means - to find the beginning of a next message skip 4 rows
and 8 columns. That&amp;rsquo;s it!&lt;/p&gt;
&lt;h2 id=&#34;decoding-ascii-from-hex-in-mind&#34;&gt;Decoding ascii from hex in mind&lt;/h2&gt;
&lt;p&gt;Some of the protocols are binary, but some are textual. &lt;code&gt;hexdump -C&lt;/code&gt; is a nice thing
display both, but from time to time there are situations where you have just a wall
of hex bytes. Turned out that there are some easy rules you can decode text from the
ascii bytes.&lt;/p&gt;
&lt;p&gt;So, what I ended up with: 30 in hex actually means &amp;lsquo;0&amp;rsquo;. It is very convinient. All of
the hex numbers in the range 30-39, just drop &amp;lsquo;3&amp;rsquo;, and you have a digit.
40 - is a character &amp;lsquo;before&amp;rsquo; the alphabet. So that &amp;ldquo;the first letter&amp;rdquo; - so 40 + 1, is &amp;lsquo;A&amp;rsquo;.
So, it is easy to decode 41-46 as &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;D&amp;rsquo;, &amp;lsquo;E&amp;rsquo; accordingly. 60 - is a character
&amp;lsquo;before&amp;rsquo; the lower-case alhpabet. 61 is &amp;lsquo;a&amp;rsquo;.&lt;/p&gt;
- https://xni.github.io/tech/hex-reading-interesting-facts/ - </description>
        </item>
    
    
    
        <item>
        <title>Will the exchanges survive?</title>
        <link>https://xni.github.io/finance/will-exchange-survive/</link>
        <pubDate>Mon, 06 Apr 2020 22:17:11 +0100</pubDate>
        
        <guid>https://xni.github.io/finance/will-exchange-survive/</guid>
        <description>Kostya&#39;s Blog https://xni.github.io/finance/will-exchange-survive/ -&lt;p&gt;Citadel Securuties &lt;a href=&#34;https://www.bloomberg.com/news/articles/2020-04-01/ken-griffin-s-virus-plan-now-includes-emergency-site-in-florida&#34;&gt;placed&lt;/a&gt; its high profile traders to the isolated hotel in Florida. I am not saying this post will be an absolute truth. It is just a reflection of my knowledge about finance, how I have connected the dots of facts known by me to a broader picture. Perhaps, some guys like Ray Dalio etc etc have a better clarity about all of these, but I will try.&lt;/p&gt;
&lt;p&gt;So, why the exchanges remained open during the coronavirus outbreak?
I think the answer lies in the realization how deep we are drawn into the &amp;lsquo;investments&amp;rsquo;.&lt;/p&gt;
&lt;p&gt;Investments were there for a very long time. Mostly in the form of fundraising:
trading ships, manufacturing and even wars. But what did it so crucial in our day to day lives?&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a step back. Can you imagine an old farmer of X-th century dreaming about passive income?
Probably, not. But actually he usually was doing a good investments in another way: children.
Seriously, if you have lots of children who are healthy, not lazy, strong, they will care
about you when you will get older. So helping them to grow up was a thing.&lt;/p&gt;
&lt;p&gt;Later on, we moved from the agricultural society to the manufacturing one.
And capitalists entered the game. Generally, if you were able to accumulate some capital,
you can get some profits by running your factory, by creating jobs. And being a capitalist was
a way to create a passive income.&lt;/p&gt;
&lt;p&gt;Later on, some people realized, that even if you don&amp;rsquo;t have enough funds to open a
factory by your own, you can own a factory together. And here we are welcoming a
stock exchanges, first IPOs and so on.&lt;/p&gt;
&lt;p&gt;Up to this point, things are logical to me.
So, what we observed was: we need exchanges in order to people who want to invest now,
in order to receive some money flow in the future, can meet each other.&lt;/p&gt;
&lt;p&gt;This idea became so popular, that now everyone is an investor.
Because our goverments are literally telling us - you don&amp;rsquo;t have any other way
to have a chance to retire, other than being an investor. We will not care about you.
Your children will not care about you. Only participating in some capitalistic
businesses is a way to have your bread and water in the future.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s why the exchange in my opinion is equal to the capitalism.
If the goverment orders to close NASDAQ, it will move us back to square one.
It is the only allowed religion of current days: &amp;ldquo;in order to have passive
income - invest&amp;rdquo; (well, for average people, extraordinary guys have some other
options).&lt;/p&gt;
&lt;p&gt;This opens some other interesting questions: how durable is this model? Generally,
if everyone will become an investor, investing 90% of their money to something,
how profitable it will be? If we will be spending money only on food,
what can we invest to? Only to agriculture.
These will be the only businesses. And then, you will also work
only there. It looks like a loop. And we are back to square 1. That&amp;rsquo;s why we
need some money spoiling habits, because they free some money from the system,
it is a way to create slavery from the people who prefer to spend now rather than
to save. Please, love them. They and their children will work in order to
make your retirement smooth and happy.&lt;/p&gt;
- https://xni.github.io/finance/will-exchange-survive/ - </description>
        </item>
    
    
  </channel>
</rss> 