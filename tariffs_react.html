<!-- index.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>React Tutorial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.0.2/react.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.0.2/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>
    <script type="text/javascript">
    var mrt_tariff = {
	"_id" : "57247fcea141bb4ec288eb2b",
	"date_from" : "2016-04-30T09:50:06.250Z",
	"home_zone" : "moscow",
	"categories" : [
		{
			"pddpi" : [
				{
					"p" : 20,
					"b" : 0
				}
			],
			"name" : "business",
			"dayoff" : false,
			"tpi" : [
				{
					"p" : 16,
					"b" : 10,
					"e" : 25
				},
				{
					"p" : 12,
					"b" : 25
				}
			],
			"st" : [
				{
					"p" : {
						"dpi" : [
							{
								"p" : 20,
								"b" : 0
							}
						],
						"tpi" : [ ]
					},
					"z" : "suburb"
				}
			],
			"currency" : "RUB",
			"waiting" : 5,
			"req_prices" : [
				{
					"p" : 150,
					"t" : "animaltransport"
				},
				{
					"p" : 150,
					"t" : "ski"
				},
				{
					"p" : 100,
					"t" : "childchair"
				},
				{
					"p" : 200,
					"t" : "bicycle"
				},
				{
					"p" : 100,
					"t" : "luggage"
				},
				{
					"p" : 0,
					"t" : "no_smoking"
				}
			],
			"from_time" : "08:00",
			"to_time" : "20:59",
			"name_key" : "interval.day",
			"dt" : 0,
			"zp" : [
				{
					"src" : "svo",
					"dst" : "seao",
					"p" : {
						"waiting" : 20,
						"tpi" : [
							{
								"p" : 16,
								"b" : 90
							}
						],
						"once" : 1400
					}
				}
			],
			"id" : "2dff49ab15904cd887dd6a4349b3aeed",
			"dpi" : [
				{
					"p" : 0,
					"b" : 0
				}
			],
			"minimal" : 299
		},
	],
	"rz" : [
		"wao",
		"svo",
		"sao",
		"dme",
		"eao",
		"nwao",
		"swao",
		"nao",
		"neao",
		"seao",
		"vko",
		"cao",
		"moscow"
	],
	"p" : "__mrt"
};

var TariffAccessor = function(tariff) {
  this.tariff = JSON.parse(JSON.stringify(tariff));
};

TariffAccessor.prototype = {
  findCategoryObject: function(categoryId) {
    for (categoryIndex = 0; categoryIndex < this.tariff.categories.length; ++categoryIndex) {
      var currentCategory = this.tariff.categories[categoryIndex];
      if (currentCategory.id === categoryId)
        return currentCategory;
    }
    console.error('Unable to find category ' + categoryId);
  },
  setRootValue: function(categoryId, key, value) {
    this.findCategoryObject(categoryId)[key] = value;
  }
};

var tariffAccessor = new TariffAccessor(mrt_tariff);
var parkTariff = JSON.parse(JSON.stringify(mrt_tariff));


    </script>
    <style>
    span.zone-name {
        font-family: monospace;
    }
    input.error {
      background-color: red;
    }
    div.category {
      border: 1px solid black;
    }
    </style>
  </head>
  <body>
    
    <div style="display: inline-block; width: 40%; height: 500px;">
<p>Тариф парка</p>
<textarea style="width: 100%; height: 100%;" id="park-tariff">
{
	"_id" : "57247fcea141bb4ec288eb2b",
	"date_from" : "2016-04-30T09:50:06.250Z",
	"home_zone" : "moscow",
	"categories" : [
		{
			"pddpi" : [
				{
					"p" : 20,
					"b" : 0
				}
			],
			"name" : "business",
			"dayoff" : false,
			"tpi" : [
				{
					"p" : 16,
					"b" : 10,
					"e" : 25
				},
				{
					"p" : 12,
					"b" : 25
				}
			],
			"st" : [
				{
					"p" : {
						"dpi" : [
							{
								"p" : 20,
								"b" : 0
							}
						],
						"tpi" : [ ]
					},
					"z" : "suburb"
				}
			],
			"currency" : "RUB",
			"waiting" : 5,
			"req_prices" : [
				{
					"p" : 150,
					"t" : "animaltransport"
				},
				{
					"p" : 150,
					"t" : "ski"
				},
				{
					"p" : 100,
					"t" : "childchair"
				},
				{
					"p" : 200,
					"t" : "bicycle"
				},
				{
					"p" : 100,
					"t" : "luggage"
				},
				{
					"p" : 0,
					"t" : "no_smoking"
				}
			],
			"from_time" : "08:00",
			"to_time" : "20:59",
			"name_key" : "interval.day",
			"dt" : 0,
			"zp" : [
				{
					"src" : "svo",
					"dst" : "seao",
					"p" : {
						"waiting" : 20,
						"tpi" : [
							{
								"p" : 16,
								"b" : 90
							}
						],
						"once" : 1400
					}
				}
			],
			"id" : "2dff49ab15904cd887dd6a4349b3aeed",
			"dpi" : [
				{
					"p" : 0,
					"b" : 0
				}
			],
			"minimal" : 299
		}
	]
}
    </textarea>
  </div>
    <div style="display: inline-block; width: 40%; height: 500px;">
<p>Максимальный тариф</p>
<textarea style="width: 100%; height: 100%;" id="mrt-tariff">
{
	"_id" : "57247fcea141bb4ec288eb2b",
	"date_from" : "2016-04-30T09:50:06.250Z",
	"home_zone" : "moscow",
	"categories" : [
		{
			"pddpi" : [
				{
					"p" : 20,
					"b" : 0
				}
			],
			"name" : "business",
			"dayoff" : false,
			"tpi" : [
				{
					"p" : 16,
					"b" : 10,
					"e" : 25
				},
				{
					"p" : 12,
					"b" : 25
				}
			],
			"st" : [
				{
					"p" : {
						"dpi" : [
							{
								"p" : 20,
								"b" : 0
							}
						],
						"tpi" : [ ]
					},
					"z" : "suburb"
				}
			],
			"currency" : "RUB",
			"waiting" : 5,
			"req_prices" : [
				{
					"p" : 150,
					"t" : "animaltransport"
				},
				{
					"p" : 150,
					"t" : "ski"
				},
				{
					"p" : 100,
					"t" : "childchair"
				},
				{
					"p" : 200,
					"t" : "bicycle"
				},
				{
					"p" : 100,
					"t" : "luggage"
				},
				{
					"p" : 0,
					"t" : "no_smoking"
				}
			],
			"from_time" : "08:00",
			"to_time" : "20:59",
			"name_key" : "interval.day",
			"dt" : 0,
			"zp" : [
				{
					"src" : "svo",
					"dst" : "seao",
					"p" : {
						"waiting" : 20,
						"tpi" : [
							{
								"p" : 16,
								"b" : 90
							}
						],
						"once" : 1400
					}
				}
			],
			"id" : "2dff49ab15904cd887dd6a4349b3aeed",
			"dpi" : [
				{
					"p" : 0,
					"b" : 0
				}
			],
			"minimal" : 299
		}
	]
}
</textarea>
  </div>
     
    <div id="content"></div>
    <script type="text/babel">
      
var ConstrainedInput = React.createClass({
  checkValue: function(value) {
    var isOk = (
      !isNaN(value) && value >= 0 && (
        (value <= this.props.baseValue && this.props.constraint == 'max') ||
        (value >= this.props.baseValue && this.props.constraint == 'min')
      )
    );
    return isOk ? 'clear' : 'error';
  },
  getInitialState: function() {
    return {
      isOk: this.checkValue(this.props.value),
      value: this.props.value,
    }
  },
  handleValueChange: function(event) {
    var value = parseFloat(event.target.value);
    var isOk = this.checkValue(value);
    this.setState({
      isOk: isOk,
      value: !isNaN(value) ? value : '',
    });

    if (isOk) {
      this.props.setter(value);
    } else {
      this.props.setter(null);
    }
  },
  render: function() {
    return (
      <input className={this.state.isOk} value={this.state.value} onChange={this.handleValueChange} />
    );
  }
});

// C-tor like, must be always called with `new`.
var GroupInput = {
  // We can not use .prototype, because react is doing exactly the same.
  getInitialState: function() {
    return { value: this.props.value }
  },
  findRelated: function(data, obj) {
    for (var i = 0; i < data.length; ++i) {
      if (this.eqFun(data[i], obj))
        return data[i];
    }
    console.error('No related object for ' + obj.toString() + ' in ' + data);
    return null;
  },
  setValue: function(obj, propertyName, value) {
    if (value === null) {
      this.props.setter(null);
      return;
    }
    var objToModify = this.findRelated(this.state.value, obj);
    var propSequence = propertyName.split('.');
    while (true) {
      var nextProp = propSequence.shift();
      if (!propSequence.length) {
        objToModify[nextProp] = value;
        break;
      } else {
        objToModify = objToModify[nextProp];
      }
    }
    this.setState(this.state.value);
    this.props.setter(this.state.value);
  },
};

var IntervalInput = React.createClass({
  mixins: [GroupInput],
  eqFun: function(a, b) { return a.b === b.b; },
  render: function() {
    var intervals = this.state.value.map(function(interval) {
      var maxPrice = this.findRelated(this.props.baseValue, interval);
      return (
        <li key={interval.b}>
          Начиная с {interval.b} [до {interval.e || this.props.e_descr}] {this.props.unit}
          <ConstrainedInput constraint='max'
                            value={interval.p}
                            baseValue={maxPrice.p}
                            setter={this.setValue.bind(this, interval, 'p')} />
        </li>
      );
    }, this);
    return (<ol>{intervals}</ol>);
  },
});

var ServicesInput = React.createClass({
  mixins: [GroupInput],
  eqFun: function(a, b) { return a.t === b.t; },
  render: function() {
    var services = this.state.value.map(function(service) {
      var maxService = this.findRelated(this.props.baseValue, service);
      return (
        <li key={service.t}>{service.t}
          <ConstrainedInput constraint='max'
                            value={service.p}
                            baseValue={maxService.p}
                            setter={this.setValue.bind(this, service, 'p')} />
        </li>
      );
    }, this);
    return (<ul>{services}</ul>);
  },
});

var SpecialTaximeterInput = React.createClass({
  mixins: [GroupInput],
  eqFun: function(a, b) { return a.z === b.z; },
  render: function() {
    var zones = this.state.value.map(function(st) {
      var maxSt = this.findRelated(this.props.baseValue, st);
      return (
        <div key={st.z}>
          <h4>{st.z}</h4>
          <p>Цена за километр:</p>
          <IntervalInput value={st.p.dpi} 
                         baseValue={maxSt.p.dpi}
                         unit='км'
                         e_descr='окончания поездки по зоне'
                         setter={this.setValue.bind(this, st, 'p.dpi')} />
          
          <p>Цена за минуту:</p>
          <IntervalInput value={st.p.tpi}
                         baseValue={maxSt.p.tpi}
                         unit='мин'
                         e_descr='окончания поездки по зоне'
                         setter={this.setValue.bind(this, st, 'p.tpi')} />
        </div>
      );
    }, this);
    return (<div>{zones}</div>);
  },
});

var TransfersInput = React.createClass({
  mixins: [GroupInput],
  eqFun: function(a, b) { return a.src === b.src && a.dst === b.dst; },
  render: function() {
    var transfers = this.state.value.map(function(trans) {
      var maxTrans = this.findRelated(this.props.baseValue, trans);
      return (
        <div key={trans.src + '-' + trans.dst}>
          <h4>{trans.src} &rarr; {trans.dst}</h4>
          <p>
            За посадку:
            <ConstrainedInput constraint='max'
                              value={trans.p.once}
                              baseValue={maxTrans.p.once}
                              setter={this.setValue.bind(this, trans, 'p.once')} />
          </p>
          <p>
            Цена поездки не меньше:
            <ConstrainedInput constraint='max'
                              value={trans.p.minimal || 0}
                              baseValue={maxTrans.p.minimal || 0}
                              setter={this.setValue.bind(this, trans, 'p.minimal')} />
          </p>
        </div>
      );
    }, this);
    return (<div>{transfers}</div>);
  },
});
      
var CategoryEditor = React.createClass({
  describeDateType: function(dt) {
    switch (dt) {
      case 0: return 'по будням';
      case 1: return 'по выходным';
      case 2: return 'ежедневно';
    }
  },
  setRootValue: function(property_name, value) {
    if (value !== null) {
      tariffAccessor.setRootValue(this.props.category.id, property_name, value);
      this.props.editor.setHasErrors(false);
    } else {
      this.props.editor.setHasErrors(true);
    }
  },
  render: function() {
    var category = this.props.category;
    var maxCategory = this.props.maxCategory;
    return (
      <div className="category">
        <h2>{category.name} ({this.describeDateType(category.dt)} c {category.from_time} до {category.to_time})</h2>
        <div>
          <p>Минимальная стоимость поездки <ConstrainedInput constraint='max'
                                                             value={category.minimal}
                                                             baseValue={maxCategory.minimal}
                                                             setter={this.setRootValue.bind(this, 'minimal')} /></p>
                                                             
          <h3>Общие параметры</h3>
          <p>Цена за километр:</p>
          <IntervalInput value={category.dpi} 
                         baseValue={maxCategory.dpi}
                         unit='км'
                         e_descr='окончания поездки'
                         setter={this.setRootValue.bind(this, 'dpi')} />
          
          <p>Цена за минуту:</p>
          <IntervalInput value={category.tpi}
                         baseValue={maxCategory.tpi}
                         unit='мин'
                         e_descr='окончания поездки'
                         setter={this.setRootValue.bind(this, 'tpi')} />
          
          <h3>Надбавки за дополнительные услуги:</h3>
          <p>Платная подача</p>
          <IntervalInput value={category.pddpi}
                         baseValue={maxCategory.pddpi}
                         unit='км'
                         e_descr='момента подачи'
                         setter={this.setRootValue.bind(this, 'pddpi')} />

          <ServicesInput value={category.req_prices}
                         baseValue={maxCategory.req_prices}
                         setter={this.setRootValue.bind(this, 'req_prices')} />
                         
          <h3>Поездки по особым зонам</h3>
          <SpecialTaximeterInput value={category.st}
                                 baseValue={maxCategory.st}
                                 setter={this.setRootValue.bind(this, 'st')} />
                                 
          <h3>Трансферы</h3>
          <TransfersInput value={category.zp}
                          baseValue={maxCategory.zp}
                          setter={this.setRootValue.bind(this, 'zp')} />
        </div>
      </div>
    );
  }
});

var TariffEditor = React.createClass({
  getInitialState: function() {
    return {
      hasErrors: false,
      hasFatalError: false,
      tariff: {categories: []},
      maxTariff: {categories: []},
    }
  },
  setHasErrors: function(flag) {
    var currentState = this.state;
    currentState.hasErrors = flag;
    this.setState(currentState);
  },
  eqFun: function(a, b) {
    return a.name === b.name &&
           a.from_time === b.from_time &&
           a.to_time === b.to_time &&
           a.dt === b.dt &&
           a.currency === b.currency;      
  },
  findRelatedCategory: function(data, category) {
    for (var categoryIndex = 0; categoryIndex < data.length; ++categoryIndex) {
      var curCategory = data[categoryIndex];
      // Do not compare IDs, they differ.
      if (this.eqFun(curCategory, category))
        return curCategory;
    }
    console.error(
        'Unable to find maxCategory for ' + category.name + ' ' + category.from_time + ' ' +
        category.to_time + ' ' + category.dt
    );
    return null;
  },
  checkKeySubset: function(a, b, eqFun) {
    if (a === null || a === undefined)
      return true;

    for (var i = 0; i < a.length; ++i) {
      var found = false;
      for (var j = 0; j < b.length; ++j) {
        if (eqFun(a[i], b[j]))
          found = true;
      }
      if (!found)
        return false;
    }
    return true;
  },
  isTariffSchemeEqual: function(parkTariff, mrtTariff) {
    // Required for future checks.
    if (!this.checkKeySubset(parkTariff.categories, mrtTariff.categories, this.eqFun))
      return false;

    for (var categoryIndex = 0; categoryIndex < parkTariff.categories.length; ++categoryIndex) {
      var curCategory = parkTariff.categories[categoryIndex];
      var mrtCategory = this.findRelatedCategory(mrtTariff.categories, curCategory);
      
      if (!this.checkKeySubset(curCategory.pddpi, mrtCategory.pddpi, IntervalInput.prototype.eqFun))
        return false;
      if (!this.checkKeySubset(curCategory.dpi, mrtCategory.dpi, IntervalInput.prototype.eqFun))
        return false;
      if (!this.checkKeySubset(curCategory.tpi, mrtCategory.tpi, IntervalInput.prototype.eqFun))
        return false;
      if (!this.checkKeySubset(curCategory.req_prices, mrtCategory.req_prices, ServicesInput.prototype.eqFun))
        return false;
        
      if (!this.checkKeySubset(curCategory.st, mrtCategory.st, SpecialTaximeterInput.prototype.eqFun))
        return false;
      var comparator = {eqFun: SpecialTaximeterInput.prototype.eqFun};
      for (var stI = 0; stI < curCategory.st.length; ++stI) {
        var curSt = curCategory.st[stI];
        var mrtSt = GroupInput.findRelated.call(comparator, mrtCategory.st, curSt);
        if (!this.checkKeySubset(curSt.p.tpi, mrtSt.p.tpi, IntervalInput.prototype.eqFun))
          return false;
        if (!this.checkKeySubset(curSt.p.dpi, mrtSt.p.dpi, IntervalInput.prototype.eqFun))
          return false;
      }
      
      if (!this.checkKeySubset(curCategory.zp, mrtCategory.zp, TransfersInput.prototype.eqFun))
        return;
      var comparator = {eqFun: TransfersInput.prototype.eqFun};
      for (var zpI = 0; zpI < curCategory.zp.length; ++zpI) {
        var curZp = curCategory.zp[zpI];
        var mrtZp = GroupInput.findRelated.call(comparator, mrtCategory.zp, curZp);
        if (!this.checkKeySubset(curZp.p.tpi, mrtZp.p.tpi, IntervalInput.prototype.eqFun))
          return false;
        if (!this.checkKeySubset(curZp.p.dpi, mrtZp.p.dpi, IntervalInput.prototype.eqFun))
          return false;
      }
      
      return true;
    }
  },
  generatePage: function(event) {
    var parkTariff = JSON.parse(document.getElementById('park-tariff').value);
    var mrtTariff = JSON.parse(document.getElementById('mrt-tariff').value);
    
    var isTariffSchemeEqual = this.isTariffSchemeEqual(parkTariff, mrtTariff);
    
    this.setState({
      hasErrors: false,
      hasFatalError: !isTariffSchemeEqual,
      tariff: parkTariff,
      maxTariff: mrtTariff,
    });
    tariffAccessor = new TariffAccessor(parkTariff);
    event.preventDefault();
  },
  handleSubmit: function(event) {
    document.getElementById('result').value = JSON.stringify(tariffAccessor.tariff, null, '  ');
    event.preventDefault();
  },
  render: function() {
    if (this.state.hasFatalError)
      return (<div>
        <h1>Ошибка!</h1>
        <p>Данные находятся в несогласованном состоянии. Просьба <em>срочно</em> связаться со службой тех. поддежрки.</p>
      </div>
    );
    var editor = this;
    var categories = this.state.tariff.categories.map(function(child) {
      var maxCategory = this.findRelatedCategory(this.state.maxTariff.categories, child);
      if (maxCategory === null) {
        console.error(
            'Unable to find maxCategory for ' + child.name + ' ' + child.from_time + ' ' +
            child.to_time + ' ' + child.dt
        );
        return (<div>Internal error</div>);
      }
      return (
        <CategoryEditor editor={editor} category={child} maxCategory={maxCategory} key={child.id} />
      );
    }, this);
    return (
      <div className="tariff-editor">
        <p><a href="#" onClick={this.generatePage}>Сгенерировать</a></p>
        <h1>Редактирование тарифа в зоне <span className="zone-name">{this.state.tariff.home_zone}</span></h1>
        {categories}
        <form onSubmit={this.handleSubmit}>
          <input type="submit" disabled={this.state.hasFatalError || this.state.hasErrors} />
        </form>
      </div>
    );
  }
});

ReactDOM.render(
  <TariffEditor />,
  document.getElementById('content')
);
    </script>
    <textarea id="result" style="height: 600px; width: 100%;"></textarea>
  </body>
</html>